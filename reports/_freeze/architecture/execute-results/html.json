{
  "hash": "d8b902c5b883ef2c0cf3fb1b8f35134b",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"MultistateModels.jl Architecture\"\nsubtitle: \"Package Structure, Design Patterns, and Implementation Details\"\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    toc-expand: 2\n    code-fold: true\n    code-summary: \"Show code\"\nexecute:\n  echo: true\n  warning: false\n  freeze: auto\n---\n\n\n\n## Overview\n\nMultistateModels.jl is a Julia package for fitting and simulating continuous-time multistate models. This document provides a comprehensive architectural overview, covering the package structure, type hierarchy, and key implementation patterns.\n\n## Package Structure\n\nThe package is organized into the following directories:\n\n```\nsrc/\n├── MultistateModels.jl      # Main module, exports, includes\n├── construction/            # Model construction (multistatemodel function)\n├── hazard/                  # Hazard functions and evaluation\n├── inference/               # MCEM, SIR, fitting algorithms\n├── likelihood/              # Log-likelihood computation\n├── output/                  # Model accessors and variance estimation\n├── phasetype/               # Phase-type distributions and FFBS\n├── simulation/              # Path simulation\n├── surrogate/               # Markov surrogates\n├── types/                   # Type definitions\n└── utilities/               # Parameter handling, validation, misc\n```\n\n## Type Hierarchy\n\n### Internal Hazard Types\n\nThe package uses an internal type hierarchy for hazard functions that distinguishes between **Markov** (time-homogeneous) and **semi-Markov** (sojourn-time-dependent) hazards:\n\n::: {#a3efd78c .cell fig-height='6' fig-width='14' execution_count=2}\n\n::: {.cell-output .cell-output-display execution_count=3}\n![](architecture_files/figure-html/cell-3-output-1.svg){}\n:::\n:::\n\n\n**Key insight:** `PhaseTypeCoxianHazard` inherits from `_MarkovHazard` because the stochastic process on the expanded state space (with latent phases) is Markovian—each phase transition is exponential. The non-exponential sojourn time arises from the *mixture* over paths through phases, not from any single transition.\n\n### Model Types\n\n::: {#6266f3a9 .cell fig-height='4' fig-width='10' execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](architecture_files/figure-html/cell-4-output-1.svg){}\n:::\n:::\n\n\n### User-Facing Hazard Specifications\n\nUsers specify hazards via `HazardFunction` subtypes, which are converted to internal types during model construction:\n\n| User Specification | Internal Type | Description |\n|-------------------|---------------|-------------|\n| `ParametricHazard` (`:exp`) | `MarkovHazard` | Exponential (constant hazard) |\n| `ParametricHazard` (`:wei`, `:gom`) | `SemiMarkovHazard` | Weibull, Gompertz |\n| `SplineHazard` (`:sp`) | `RuntimeSplineHazard` | B-spline hazard |\n| `PhaseTypeHazard` (`:pt`) | `PhaseTypeCoxianHazard` | Phase-type (Coxian) |\n\n### Trait-Based Dispatch\n\nRather than using the type hierarchy directly, model behavior is determined by **trait functions**:\n\n```julia\nis_markov(model)              # All hazards are _MarkovHazard?\nis_panel_data(model)          # Any obstype ≥ 2?\nhas_phasetype_expansion(model) # Model has phase-type hazards?\n```\n\nThese traits determine which fitting algorithm is used:\n- `is_panel_data=false` → Direct MLE (exact data)\n- `is_panel_data=true && is_markov=true` → Matrix exponential MLE\n- `is_panel_data=true && is_markov=false` → MCEM\n\n## Data Handling\n\n### Required Data Format\n\nData must be a `DataFrame` with the following columns:\n\n| Column | Type | Description |\n|--------|------|-------------|\n| `id` | Int/String | Subject identifier |\n| `tstart` | Float64 | Interval start time |\n| `tstop` | Float64 | Interval end time |\n| `statefrom` | Int | State at `tstart` |\n| `stateto` | Int | State at `tstop` |\n| `obstype` | Int | Observation type code |\n| *covariates* | Any | Model-specific covariates |\n\n### Observation Types (`obstype`)\n\nThe `obstype` column controls how each observation contributes to the likelihood:\n\n| Code | Name | Description | Likelihood Contribution |\n|------|------|-------------|------------------------|\n| 1 | Exact | Transition time and state observed exactly | Transition density |\n| 2 | Panel | State known at `tstop`, transition time unknown | TPM entry |\n| 0 | Fully censored | State unknown at `tstop` | Sum over all states |\n| ≥3 | Partially censored | State partially known (see CensoringPatterns) | Weighted sum |\n\n### CensoringPatterns\n\nFor `obstype ≥ 3`, you must provide a `CensoringPatterns` matrix specifying which states are compatible with each censoring code:\n\n```julia\n# 3-state model with two censoring patterns\n# obstype=3: states 1 or 2 possible (not 3)\n# obstype=4: states 2 or 3 possible (not 1)\nCensoringPatterns = [\n    # code  state1  state2  state3\n    3       1.0     1.0     0.0;\n    4       0.0     1.0     1.0\n]\n\nmodel = multistatemodel(h12, h23; data=dat, CensoringPatterns=CensoringPatterns)\n```\n\n### EmissionMatrix\n\nFor maximum flexibility, you can provide an observation-specific `EmissionMatrix` directly. This is an $(n_{\\text{obs}} \\times n_{\\text{states}})$ matrix where entry $(i, s)$ gives $P(\\text{observation } i \\mid \\text{state } s)$.\n\n## Hazard Families\n\n### Parametric Distributions\n\n| Family | Symbol | Parameters | Hazard $h(t)$ | Markov? |\n|--------|--------|------------|---------------|---------|\n| **Exponential** | `:exp` | `rate` $(\\lambda)$ | $\\lambda$ | ✓ |\n| **Weibull** | `:wei` | `shape` $(a)$, `scale` $(b)$ | $\\displaystyle\\frac{a}{b}\\left(\\frac{t}{b}\\right)^{a-1}$ | ✗ |\n| **Gompertz** | `:gom` | `shape` $(a)$, `rate` $(b)$ | $b \\cdot e^{at}$ | ✗ |\n| **B-Spline** | `:sp` | `coefs` $(\\beta_1,\\ldots,\\beta_K)$ | $\\exp\\left(\\sum_{k=1}^K B_k(t)\\beta_k\\right)$ | ✗ (degree>0) |\n| **Phase-Type** | `:pt` | $\\lambda_1,\\ldots,\\lambda_{n-1}$, $\\mu_1,\\ldots,\\mu_n$ | Coxian absorption | ✓ (expanded) |\n\n::: {.callout-note}\n**Gompertz Parameterization:** MultistateModels.jl uses the *flexsurv* parameterization where `shape` ($a$) is the rate of hazard increase and `rate` ($b$) is the initial hazard at $t=0$.\n:::\n\n### Phase-Type Structure\n\nPhase-type hazards (`:pt`) use a Coxian structure with latent phases:\n\n::: {#0450b237 .cell fig-height='5' fig-width='12' execution_count=4}\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](architecture_files/figure-html/cell-5-output-1.svg){}\n:::\n:::\n\n\n**Key properties:**\n\n- Approximate any non-negative distribution arbitrarily well\n- **The process on the expanded state space is Markovian** — hence `PhaseTypeCoxianHazard <: _MarkovHazard`\n- Non-exponential sojourn times arise from the mixture over phase paths\n- Parameters: $\\lambda_1, \\ldots, \\lambda_{n-1}$ (progression), $\\mu_1, \\ldots, \\mu_n$ (exit)\n\n### Covariate Effects\n\nTwo covariate effect types are supported:\n\n**Proportional Hazards (PH):**\n$$h(t|\\mathbf{x}) = h_0(t) \\exp(\\mathbf{x}'\\boldsymbol{\\beta})$$\n\n**Accelerated Failure Time (AFT):**\n$$h(t|\\mathbf{x}) = h_0(t \\cdot e^{\\mathbf{x}'\\boldsymbol{\\beta}}) \\cdot e^{\\mathbf{x}'\\boldsymbol{\\beta}}$$\n\n```julia\n# Specify effect type when creating hazards\nh12_ph = Hazard(@formula(0 ~ 1 + age), \"wei\", 1, 2; linpred_effect=:ph)\nh12_aft = Hazard(@formula(0 ~ 1 + age), \"wei\", 1, 2; linpred_effect=:aft)\n```\n\n::: {.callout-warning}\nThe covariate effect types (`:ph` and `:aft`) are built into the package. Adding custom effect types requires modifying the hazard generation code—this is **not user-extensible**.\n:::\n\n## Parameter Handling\n\n### Parameter Structure\n\nParameters are stored as **NamedTuples** with multiple representations:\n\n```julia\nmodel.parameters = (\n    flat = [...],           # Flat vector on estimation (log) scale\n    nested = (...),         # Nested NamedTuple by hazard\n    natural = (...),        # Natural scale values by hazard\n    reconstructor = ...     # Function to unflatten\n)\n```\n\nEach hazard's parameters include:\n- Baseline parameters (`shape`, `scale`, `rate`, `coefs`, etc.)\n- Regression coefficients (if covariates specified)\n\n### Scale Transformations\n\nParameters are estimated on transformed scales for numerical stability:\n\n| Parameter Type | Natural Scale | Estimation Scale | Transformation |\n|---------------|---------------|------------------|----------------|\n| Rates, shapes, scales | $(0, \\infty)$ | $(-\\infty, \\infty)$ | $\\log$ |\n| Spline coefficients | $(-\\infty, \\infty)$ | $(-\\infty, \\infty)$ | Identity |\n| Regression $\\beta$ | $(-\\infty, \\infty)$ | $(-\\infty, \\infty)$ | Identity |\n\n**Transformation by family:**\n\n| Family | Parameter | Natural | Estimation | Transform |\n|--------|-----------|---------|------------|-----------|\n| Exponential | `rate` | $\\lambda > 0$ | $\\theta \\in \\mathbb{R}$ | $\\lambda = e^\\theta$ |\n| Weibull | `shape` | $a > 0$ | $\\theta_a \\in \\mathbb{R}$ | $a = e^{\\theta_a}$ |\n| Weibull | `scale` | $b > 0$ | $\\theta_b \\in \\mathbb{R}$ | $b = e^{\\theta_b}$ |\n| Gompertz | `shape` | $a \\in \\mathbb{R}$ | $a$ | Identity |\n| Gompertz | `rate` | $b > 0$ | $\\theta_b \\in \\mathbb{R}$ | $b = e^{\\theta_b}$ |\n| Spline | `coefs` | $\\boldsymbol{\\beta}$ | $\\boldsymbol{\\beta}$ | Identity |\n\n```julia\n# Access parameters in different scales\np_natural = model.parameters.natural   # Interpretable values\np_flat = model.parameters.flat         # For optimization (log scale)\n```\n\n## Inference Methods\n\n### Fitting Strategy Selection\n\nThe `fit()` function automatically selects the appropriate method based on data and hazard types:\n\n::: {#6045a2db .cell fig-height='5' fig-width='10' execution_count=5}\n\n::: {.cell-output .cell-output-display execution_count=6}\n![](architecture_files/figure-html/cell-6-output-1.svg){}\n:::\n:::\n\n\n### Direct MLE (Exact Data)\n\nFor exactly observed data (`obstype=1`), the likelihood factorizes into transition densities:\n\n$$\\mathcal{L}(\\boldsymbol{\\theta}) = \\prod_{i} \\prod_{j} h_{s_j \\to s_{j+1}}(t_j) \\cdot S_{s_j}(t_j - t_{j-1})$$\n\nwhere $S_s(t) = \\exp(-H_s(t))$ is the survival probability in state $s$.\n\n### Matrix Exponential MLE (Markov Panel)\n\nFor panel data with Markov hazards (exponential or phase-type), the likelihood uses transition probability matrices:\n\n$$P(t_0, t_1) = \\exp(\\mathbf{Q} \\cdot (t_1 - t_0))$$\n\nwhere $\\mathbf{Q}$ is the generator matrix.\n\n### Monte Carlo EM (Semi-Markov Panel)\n\nFor panel data with semi-Markov hazards (Weibull, Gompertz, degree>0 splines), MCEM is used:\n\n**E-step:** Sample latent paths via importance sampling using a Markov surrogate\n\n**M-step:** Maximize expected complete-data log-likelihood with importance weights\n\n**Features:**\n- SQUAREM acceleration\n- Adaptive ESS targeting\n- Latin Hypercube Sampling (LHS) for variance-reduced resampling\n\n### Forward-Filtering Backward-Sampling (FFBS)\n\nFFBS samples latent state sequences given observations. For phase-type models, FFBS operates on the expanded Markov state space, then collapses sampled phases back to observed states.\n\nSee the [Phase-Type FFBS documentation](https://fintzij.github.io/MultistateModels.jl/phasetype_ffbs) for details.\n\n## Variance Estimation\n\nThree variance estimation approaches are available:\n\n| Method | Description | Pros | Cons |\n|--------|-------------|------|------|\n| **Model-based** | Inverse Hessian at MLE | Fast, standard | Assumes correct model |\n| **Sandwich (IJ)** | Infinitesimal jackknife | Robust to misspecification | Requires more computation |\n| **Jackknife** | Leave-one-out refitting | Nonparametric | Computationally expensive |\n\n```julia\nfitted = fit(model; \n    compute_vcov=true,      # Model-based (default)\n    compute_ij_vcov=true,   # Sandwich estimator\n    compute_jk_vcov=false   # Jackknife (slow)\n)\n```\n\n## Custom Constraints\n\nUsers can specify parameter constraints using expressions that reference parameter names:\n\n```julia\n# Constraint: shape parameter must be ≥ 1\n# Constraint: two hazards share the same rate\nconstraints = make_constraints(\n    cons = [\n        :(h1_2_shape - 1),           # shape ≥ 1 → (shape - 1) ≥ 0\n        :(h1_2_rate - h2_3_rate)     # Equal rates → difference = 0\n    ],\n    lcons = [0.0, 0.0],   # Lower bounds\n    ucons = [Inf, 0.0]    # Upper bounds\n)\n\nfitted = fit(model; constraints=constraints)\n```\n\n**Parameter naming:** `h{from}_{to}_{param}` (e.g., `h1_2_shape`, `h2_3_rate`)\n\n::: {.callout-warning}\nVariance-covariance matrices are not computed when constraints are active, as the constrained MLE may lie on the boundary of the parameter space.\n:::\n\n## Simulation Engine\n\nThe simulation engine samples complete state trajectories:\n\n1. **Initialize** at starting state and time\n2. **Compute** total hazard from current state\n3. **Sample** waiting time via inverse CDF\n4. **Sample** destination state proportional to hazard rates\n5. **Update** state and time\n6. **Repeat** until absorbing state or end time\n\n```julia\npaths = simulate(model; nsim=1000, tmax=10.0)\n```\n\n## Summary\n\nMultistateModels.jl provides a flexible framework for multistate modeling:\n\n1. **Type hierarchy:** `_MarkovHazard` vs `_SemiMarkovHazard` governs fitting method selection\n2. **Phase-type hazards** are Markovian on the expanded space (not semi-Markov!)\n3. **Trait-based dispatch** via `is_markov()`, `is_panel_data()`, `has_phasetype_expansion()`\n4. **Parameters as NamedTuples** with flat/nested/natural representations\n5. **Flexible observation handling** via `obstype`, `CensoringPatterns`, `EmissionMatrix`\n6. **Three fitting algorithms:** Direct MLE, Matrix Exp MLE, MCEM (auto-selected)\n7. **LHS resampling** for variance-reduced importance sampling in MCEM\n\n",
    "supporting": [
      "architecture_files"
    ],
    "filters": [],
    "includes": {}
  }
}