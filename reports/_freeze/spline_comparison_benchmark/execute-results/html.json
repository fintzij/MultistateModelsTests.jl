{
  "hash": "ac9274a4ae92c25966611cb066239f74",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Spline Methods Comparison\"\nsubtitle: \"Comparing MultistateModels.jl Splines vs mgcv and flexsurv\"\ndate: last-modified\nformat:\n  html:\n    toc: true\n    toc-depth: 3\n    code-fold: true\n    fig-width: 10\n    fig-height: 6\nexecute:\n  warning: false\n  message: false\n  freeze: auto\nengine: knitr\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(mgcv)\nlibrary(pammtools)\nlibrary(flexsurv)\nlibrary(survival)\nlibrary(patchwork)\nlibrary(knitr)\nlibrary(kableExtra)\n\n# Set theme\ntheme_set(theme_bw(base_size = 12))\n```\n:::\n\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ../..\njulia --project=. -e '\nusing MultistateModels\nusing Random\nusing DataFrames\nusing CSV\nusing Printf\n\n# Configuration\nn = 100\ntrue_shape = 1.5\ntrue_rate = 0.3\nmax_time = 5.0\nseed = 12345\nnknots = 5  # Number of interior knots\n\nRandom.seed!(seed)\n\n# Simulate Weibull survival data\nE = -log.(rand(n))\nevent_times = (E ./ true_rate) .^ (1 / true_shape)\nobs_times = min.(event_times, max_time)\nstatus = Int.(event_times .<= max_time)\n\nprintln(\"=== Simple Survival Data ===\")\nprintln(\"n = $n\")\nprintln(\"Events: $(sum(status))\")\nprintln(\"Censored: $(n - sum(status))\")\nprintln(\"Time range: [$(round(minimum(obs_times), digits=3)), $(round(maximum(obs_times), digits=3))]\")\n\n# Create multistate model data\nsurv_data = DataFrame(\n    id = 1:n,\n    tstart = zeros(n),\n    tstop = obs_times,\n    statefrom = ones(Int, n),\n    stateto = ifelse.(status .== 1, 2, 1),\n    obstype = ones(Int, n)\n)\n\n# Save to CSV for R to read\nCSV.write(\"MultistateModelsTests/reports/_surv_data.csv\", DataFrame(time = obs_times, status = status))\n\n# Define model with spline hazard (initial knots will be replaced by calibration)\nh12 = Hazard(@formula(0 ~ 1), \"sp\", 1, 2;\n             degree = 3,\n             knots = Float64[],  # Will be set by calibrate_splines!\n             boundaryknots = [0.0, max_time],\n             natural_spline = true)\nmodel = multistatemodel(h12; data=surv_data)\n\n# Calibrate knots based on data - places knots at quantiles of event times\nprintln(\"\\nCalibrating spline knots...\")\nknot_result = calibrate_splines!(model; nknots=nknots, verbose=true)\n\n# Extract the calibrated knots\ninterior_knots = knot_result.h12.interior_knots\nboundary_knots = knot_result.h12.boundary_knots\nall_knots = model.hazards[1].knots\n\nprintln(\"\\n=== Knot Configuration ===\")\nprintln(\"Boundary knots: $(boundary_knots)\")\nprintln(\"Interior knots: $(round.(interior_knots, digits=3))\")\nprintln(\"Number of interior knots: $(length(interior_knots))\")\nprintln(\"Total knots: $(length(all_knots))\")\nprintln(\"Number of basis functions: $(length(model.hazards[1].parnames) - length(model.hazards[1].covar_names))\")\n\n# Save knots for R to use\nCSV.write(\"MultistateModelsTests/reports/_knots.csv\", DataFrame(\n    interior_knots = interior_knots,\n    boundary_lower = fill(boundary_knots[1], length(interior_knots)),\n    boundary_upper = fill(boundary_knots[2], length(interior_knots))\n))\n\n# Fit with each smoothing method and measure runtime\n# Run each method twice: first for JIT compilation, second for timing\ntimings = Dict{String, Float64}()\n\nprintln(\"\\n=== Fitting Smoothing Methods with Timing ===\")\n\n# PIJCV (LOO) - Newton-approximated\nprintln(\"\\nFitting with PIJCV (LOO) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :pijcv, verbose = false)  # warmup\nt_pijcv = @elapsed result_pijcv = select_smoothing_parameters(model, SplinePenalty(); \n                                           method = :pijcv, verbose = false)\ntimings[\"PIJCV\"] = t_pijcv\nprintln(\"  PIJCV λ = $(round(result_pijcv.lambda[1], digits=2)), EDF = $(round(result_pijcv.edf.total, digits=2)), time = $(round(t_pijcv, digits=3))s\")\n\n# PIJCV5 (5-fold) - Newton-approximated\nprintln(\"\\nFitting with PIJCV5 (5-fold) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :pijcv5, verbose = false)  # warmup\nt_pijcv5 = @elapsed result_pijcv5 = select_smoothing_parameters(model, SplinePenalty(); \n                                            method = :pijcv5, verbose = false)\ntimings[\"PIJCV5\"] = t_pijcv5\nprintln(\"  PIJCV5 λ = $(round(result_pijcv5.lambda[1], digits=2)), EDF = $(round(result_pijcv5.edf.total, digits=2)), time = $(round(t_pijcv5, digits=3))s\")\n\n# PIJCV10 (10-fold) - Newton-approximated\nprintln(\"\\nFitting with PIJCV10 (10-fold) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :pijcv10, verbose = false)  # warmup\nt_pijcv10 = @elapsed result_pijcv10 = select_smoothing_parameters(model, SplinePenalty(); \n                                             method = :pijcv10, verbose = false)\ntimings[\"PIJCV10\"] = t_pijcv10\nprintln(\"  PIJCV10 λ = $(round(result_pijcv10.lambda[1], digits=2)), EDF = $(round(result_pijcv10.edf.total, digits=2)), time = $(round(t_pijcv10, digits=3))s\")\n\n# PIJCV20 (20-fold) - Newton-approximated\nprintln(\"\\nFitting with PIJCV20 (20-fold) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :pijcv20, verbose = false)  # warmup\nt_pijcv20 = @elapsed result_pijcv20 = select_smoothing_parameters(model, SplinePenalty(); \n                                             method = :pijcv20, verbose = false)\ntimings[\"PIJCV20\"] = t_pijcv20\nprintln(\"  PIJCV20 λ = $(round(result_pijcv20.lambda[1], digits=2)), EDF = $(round(result_pijcv20.edf.total, digits=2)), time = $(round(t_pijcv20, digits=3))s\")\n\n# EFS\nprintln(\"\\nFitting with EFS method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :efs, verbose = false)  # warmup\nt_efs = @elapsed result_efs = select_smoothing_parameters(model, SplinePenalty(); \n                                         method = :efs, verbose = false)\ntimings[\"EFS\"] = t_efs\nprintln(\"  EFS λ = $(round(result_efs.lambda[1], digits=2)), EDF = $(round(result_efs.edf.total, digits=2)), time = $(round(t_efs, digits=3))s\")\n\n# LOOCV (exact) - expensive\nprintln(\"\\nFitting with LOOCV (exact) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :loocv, verbose = false)  # warmup\nt_loocv = @elapsed result_loocv = select_smoothing_parameters(model, SplinePenalty(); \n                                           method = :loocv, verbose = false)\ntimings[\"LOOCV\"] = t_loocv\nprintln(\"  LOOCV λ = $(round(result_loocv.lambda[1], digits=2)), EDF = $(round(result_loocv.edf.total, digits=2)), time = $(round(t_loocv, digits=3))s\")\n\n# CV5 (exact 5-fold)\nprintln(\"\\nFitting with 5-fold CV (exact) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :cv5, verbose = false)  # warmup\nt_cv5 = @elapsed result_cv5 = select_smoothing_parameters(model, SplinePenalty(); \n                                         method = :cv5, verbose = false)\ntimings[\"CV5\"] = t_cv5\nprintln(\"  CV5 λ = $(round(result_cv5.lambda[1], digits=2)), EDF = $(round(result_cv5.edf.total, digits=2)), time = $(round(t_cv5, digits=3))s\")\n\n# CV10 (exact 10-fold)\nprintln(\"\\nFitting with 10-fold CV (exact) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :cv10, verbose = false)  # warmup\nt_cv10 = @elapsed result_cv10 = select_smoothing_parameters(model, SplinePenalty(); \n                                          method = :cv10, verbose = false)\ntimings[\"CV10\"] = t_cv10\nprintln(\"  CV10 λ = $(round(result_cv10.lambda[1], digits=2)), EDF = $(round(result_cv10.edf.total, digits=2)), time = $(round(t_cv10, digits=3))s\")\n\n# CV20 (exact 20-fold)\nprintln(\"\\nFitting with 20-fold CV (exact) method...\")\nselect_smoothing_parameters(model, SplinePenalty(); method = :cv20, verbose = false)  # warmup\nt_cv20 = @elapsed result_cv20 = select_smoothing_parameters(model, SplinePenalty(); \n                                          method = :cv20, verbose = false)\ntimings[\"CV20\"] = t_cv20\nprintln(\"  CV20 λ = $(round(result_cv20.lambda[1], digits=2)), EDF = $(round(result_cv20.edf.total, digits=2)), time = $(round(t_cv20, digits=3))s\")\n\n# Evaluation grid\neval_times = collect(range(0.01, max_time, length=200))\n\n# Function to evaluate hazard at a grid of times\nfunction evaluate_curves(model, beta, eval_times)\n    haz = model.hazards[1]\n    \n    # Use hazard_fn and cumhaz_fn (the callable functions)\n    hazard_vals = [haz.hazard_fn(t, beta, ()) for t in eval_times]\n    cumhaz_vals = [haz.cumhaz_fn(0.0, t, beta, ()) for t in eval_times]\n    survival_vals = exp.(-cumhaz_vals)\n    \n    return (hazard = hazard_vals, cumhaz = cumhaz_vals, survival = survival_vals)\nend\n\n# Compute curves for each method\ncurves_pijcv = evaluate_curves(model, result_pijcv.beta, eval_times)\ncurves_pijcv5 = evaluate_curves(model, result_pijcv5.beta, eval_times)\ncurves_pijcv10 = evaluate_curves(model, result_pijcv10.beta, eval_times)\ncurves_pijcv20 = evaluate_curves(model, result_pijcv20.beta, eval_times)\ncurves_efs = evaluate_curves(model, result_efs.beta, eval_times)\ncurves_loocv = evaluate_curves(model, result_loocv.beta, eval_times)\ncurves_cv5 = evaluate_curves(model, result_cv5.beta, eval_times)\ncurves_cv10 = evaluate_curves(model, result_cv10.beta, eval_times)\ncurves_cv20 = evaluate_curves(model, result_cv20.beta, eval_times)\n\n# Compute unpenalized log-likelihoods using ExactData\nsamplepaths = MultistateModels.extract_paths(model)\nexact_data = MultistateModels.ExactData(model, samplepaths)\nloglik_pijcv = MultistateModels.loglik_exact(result_pijcv.beta, exact_data; neg=false)\nloglik_pijcv5 = MultistateModels.loglik_exact(result_pijcv5.beta, exact_data; neg=false)\nloglik_pijcv10 = MultistateModels.loglik_exact(result_pijcv10.beta, exact_data; neg=false)\nloglik_pijcv20 = MultistateModels.loglik_exact(result_pijcv20.beta, exact_data; neg=false)\nloglik_efs = MultistateModels.loglik_exact(result_efs.beta, exact_data; neg=false)\nloglik_loocv = MultistateModels.loglik_exact(result_loocv.beta, exact_data; neg=false)\nloglik_cv5 = MultistateModels.loglik_exact(result_cv5.beta, exact_data; neg=false)\nloglik_cv10 = MultistateModels.loglik_exact(result_cv10.beta, exact_data; neg=false)\nloglik_cv20 = MultistateModels.loglik_exact(result_cv20.beta, exact_data; neg=false)\n\n# Save Julia results for R plotting\njulia_results = DataFrame(\n    time = repeat(eval_times, 9),\n    hazard = vcat(curves_pijcv.hazard, curves_pijcv5.hazard, curves_pijcv10.hazard, curves_pijcv20.hazard,\n                  curves_efs.hazard, curves_loocv.hazard, \n                  curves_cv5.hazard, curves_cv10.hazard, curves_cv20.hazard),\n    cumhaz = vcat(curves_pijcv.cumhaz, curves_pijcv5.cumhaz, curves_pijcv10.cumhaz, curves_pijcv20.cumhaz,\n                  curves_efs.cumhaz, curves_loocv.cumhaz, \n                  curves_cv5.cumhaz, curves_cv10.cumhaz, curves_cv20.cumhaz),\n    survival = vcat(curves_pijcv.survival, curves_pijcv5.survival, curves_pijcv10.survival, curves_pijcv20.survival,\n                    curves_efs.survival, curves_loocv.survival, \n                    curves_cv5.survival, curves_cv10.survival, curves_cv20.survival),\n    method = repeat([\"Julia PIJCV\", \"Julia PIJCV5\", \"Julia PIJCV10\", \"Julia PIJCV20\",\n                     \"Julia EFS\", \"Julia LOOCV\", \n                     \"Julia CV5\", \"Julia CV10\", \"Julia CV20\"], inner=length(eval_times))\n)\nCSV.write(\"MultistateModelsTests/reports/_julia_curves.csv\", julia_results)\n\n# Save summary stats with unpenalized log-likelihoods and timing\njulia_summary = DataFrame(\n    method = [\"PIJCV\", \"PIJCV5\", \"PIJCV10\", \"PIJCV20\", \"EFS\", \"LOOCV\", \"CV5\", \"CV10\", \"CV20\"],\n    lambda = [result_pijcv.lambda[1], result_pijcv5.lambda[1], result_pijcv10.lambda[1], result_pijcv20.lambda[1],\n              result_efs.lambda[1], result_loocv.lambda[1], \n              result_cv5.lambda[1], result_cv10.lambda[1], result_cv20.lambda[1]],\n    edf = [result_pijcv.edf.total, result_pijcv5.edf.total, result_pijcv10.edf.total, result_pijcv20.edf.total,\n           result_efs.edf.total, result_loocv.edf.total, \n           result_cv5.edf.total, result_cv10.edf.total, result_cv20.edf.total],\n    loglik = [loglik_pijcv, loglik_pijcv5, loglik_pijcv10, loglik_pijcv20,\n              loglik_efs, loglik_loocv, loglik_cv5, loglik_cv10, loglik_cv20],\n    runtime_sec = [timings[\"PIJCV\"], timings[\"PIJCV5\"], timings[\"PIJCV10\"], timings[\"PIJCV20\"],\n                   timings[\"EFS\"], timings[\"LOOCV\"], \n                   timings[\"CV5\"], timings[\"CV10\"], timings[\"CV20\"]]\n)\nCSV.write(\"MultistateModelsTests/reports/_julia_summary.csv\", julia_summary)\n\nprintln(\"\\n=== Runtime Summary ===\")\nprintln(\"Newton-approximated CV methods:\")\nprintln(\"  PIJCV (LOO): $(round(timings[\"PIJCV\"], digits=3))s\")\nprintln(\"  PIJCV5:      $(round(timings[\"PIJCV5\"], digits=3))s\")\nprintln(\"  PIJCV10:     $(round(timings[\"PIJCV10\"], digits=3))s\")\nprintln(\"  PIJCV20:     $(round(timings[\"PIJCV20\"], digits=3))s\")\nprintln(\"Other analytical methods:\")\nprintln(\"  EFS:         $(round(timings[\"EFS\"], digits=3))s\")\nprintln(\"Exact CV methods:\")\nprintln(\"  LOOCV:       $(round(timings[\"LOOCV\"], digits=3))s\")\nprintln(\"  CV5:         $(round(timings[\"CV5\"], digits=3))s\")\nprintln(\"  CV10:        $(round(timings[\"CV10\"], digits=3))s\")\nprintln(\"  CV20:        $(round(timings[\"CV20\"], digits=3))s\")\n\nprintln(\"\\nJulia curves computed and saved.\")\n'\n```\n:::\n\n\n# Introduction\n\nThis report presents a comprehensive benchmark comparing spline-based survival models \nacross different software packages and smoothing parameter selection methods.\n\n## Comparison Overview\n\n**Packages:**\n\n1. **MultistateModels.jl** (Julia): Penalized likelihood with P-splines using the \n   **General P-Spline (GPS)** penalty from Li & Cao (2022), which correctly handles \n   non-uniform knot spacing via weighted differences\n2. **mgcv** (R): Generalized additive models via piecewise-exponential/Poisson\n3. **flexsurv** (R): Flexible parametric survival models with spline hazards\n\n**Smoothing Parameter Selection Methods:**\n\n| Package | Method | Description | Reference |\n|---------|--------|-------------|-----------|\n| MultistateModels.jl | PIJCV | Newton-approx LOO CV | Wood (2024) |\n| MultistateModels.jl | PIJCV5 | Newton-approx 5-fold CV | Extended from Wood (2024) |\n| MultistateModels.jl | PIJCV10 | Newton-approx 10-fold CV | Extended from Wood (2024) |\n| MultistateModels.jl | PIJCV20 | Newton-approx 20-fold CV | Extended from Wood (2024) |\n| MultistateModels.jl | EFS | Extended Fellner-Schall | Wood & Fasiolo (2017) |\n| MultistateModels.jl | LOOCV | Exact Leave-One-Out CV | (refits n times) |\n| MultistateModels.jl | CV5 | Exact 5-Fold CV | (refits 5 times) |\n| MultistateModels.jl | CV10 | Exact 10-Fold CV | (refits 10 times) |\n| MultistateModels.jl | CV20 | Exact 20-Fold CV | (refits 20 times) |\n| mgcv | GCV.Cp | Generalized CV via Poisson GAM | Wood (2017) |\n| mgcv | REML | Restricted ML | Wood (2011) |\n\n# Part 1: Simple Survival Model\n\nWe start with the simplest case: a two-state survival model with a single transition \nfrom alive (state 1) to dead (state 2).\n\n## True Model Specification\n\nData are simulated from a Weibull hazard with:\n\n- **Shape ($\\kappa$)**: 1.5 (increasing hazard)\n- **Rate ($\\lambda$)**: 0.3\n- **Sample size**: 100\n\n$$h(t) = \\kappa \\cdot \\lambda \\cdot t^{\\kappa - 1} = 1.5 \\times 0.3 \\times t^{0.5} = 0.45 \\sqrt{t}$$\n\n$$H(t) = \\lambda \\cdot t^{\\kappa} = 0.3 \\cdot t^{1.5}$$\n\n$$S(t) = \\exp(-H(t)) = \\exp(-0.3 \\cdot t^{1.5})$$\n\n## Load Julia Results in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load simulated data\nsurv_data <- read.csv(\"_surv_data.csv\")\nn <- nrow(surv_data)\ntrue_shape <- 1.5\ntrue_rate <- 0.3\nmax_time <- 5.0\n\n# Load Julia curves\njulia_curves <- read.csv(\"_julia_curves.csv\")\njulia_summary <- read.csv(\"_julia_summary.csv\")\n\n# Load knots calibrated by Julia (from event time quantiles)\nknots_df <- read.csv(\"_knots.csv\")\ninterior_knots <- knots_df$interior_knots\nboundary_lower <- knots_df$boundary_lower[1]\nboundary_upper <- knots_df$boundary_upper[1]\n\ncat(\"=== Julia MultistateModels.jl Results ===\\n\")\nprint(julia_summary)\n\ncat(\"\\n=== Knot Configuration (shared across all methods) ===\\n\")\ncat(\"Boundary knots: [\", boundary_lower, \",\", boundary_upper, \"]\\n\")\ncat(\"Interior knots:\", round(interior_knots, 3), \"\\n\")\ncat(\"Number of interior knots:\", length(interior_knots), \"\\n\")\n```\n:::\n\n\n## True Hazard and Survival Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# True hazard function (Weibull with rate parameterization)\ntrue_hazard <- function(t, shape = true_shape, rate = true_rate) {\n  shape * rate * t^(shape - 1)\n}\n\n# True cumulative hazard\ntrue_cumhaz <- function(t, shape = true_shape, rate = true_rate) {\n  rate * t^shape\n}\n\n# True survival function\ntrue_surv <- function(t, shape = true_shape, rate = true_rate) {\n  exp(-true_cumhaz(t, shape, rate))\n}\n\n# True CDF (cumulative incidence for single transition)\ntrue_cdf <- function(t, shape = true_shape, rate = true_rate) {\n  1 - true_surv(t, shape, rate)\n}\n```\n:::\n\n\n## mgcv PAM Fit\n\nWe fit a piecewise-exponential additive model (PAM) using `mgcv::gam` with Poisson \nlikelihood. This transforms the survival problem into a Poisson regression.\n**mgcv uses the exact same knots as Julia** via manual knot specification for P-splines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create Surv object\nsurv_obj <- Surv(surv_data$time, surv_data$status)\n\n# Add id column if not present\nsurv_data_ped <- surv_data %>% mutate(id = row_number())\n\n# Use pammtools to create piecewise-exponential data (PED)\n# This handles the data transformation properly\nped <- as_ped(\n  formula = Surv(time, status) ~ 1,\n  data = surv_data_ped,\n  id = \"id\"\n)\n\ncat(\"PED data structure (via pammtools):\\n\")\ncat(\"  Total pseudo-observations:\", nrow(ped), \"\\n\")\ncat(\"  Events in PED:\", sum(ped$ped_status), \"\\n\")\n\n# For mgcv P-splines with manual knots:\n# - k is the basis dimension\n# - m is the spline order (m=2 for cubic, with 2nd order difference penalty)\n# - Need k + m + 2 knots total\n# - The middle k - m knots must span the data range\n# - P-splines require EVENLY SPACED knots for proper penalty behavior\n\n# Julia uses 5 interior knots + 2 boundary = 7 middle knots\n# So k - m = 7, and with m = 2, we have k = 9\nk_mgcv <- length(interior_knots) + 4  # 5 + 4 = 9\nm_order <- 2\n\n# Build the full knot sequence for P-splines\n# Middle knots: [boundary_lower, interior_knots, boundary_upper]\nmiddle_knots <- c(boundary_lower, interior_knots, boundary_upper)\n\n# Need (k + m + 2) - (k - m) = 2m + 2 = 6 padding knots (3 on each side)\n# P-splines require evenly spaced knots - use average spacing for padding\n# Note: Padding knots extend below 0 but this is just for basis construction;\n# the hazard is never evaluated at negative times\ndelta <- mean(diff(middle_knots))\npadding_lower <- boundary_lower - (3:1) * delta\npadding_upper <- boundary_upper + (1:3) * delta\n\n# Full knot sequence\nmgcv_knots <- c(padding_lower, middle_knots, padding_upper)\n\ncat(\"\\n=== Knot Configuration ===\\n\")\ncat(\"Julia interior knots:\", round(interior_knots, 3), \"\\n\")\ncat(\"Middle knots (k-m =\", length(middle_knots), \"):\", round(middle_knots, 3), \"\\n\")\ncat(\"Full P-spline knots (k+m+2 =\", length(mgcv_knots), \"):\", round(mgcv_knots, 3), \"\\n\")\ncat(\"Average knot spacing (delta):\", round(delta, 3), \"\\n\")\ncat(\"mgcv k =\", k_mgcv, \", m =\", m_order, \"\\n\")\n\n# Fit PAM with GCV using P-splines and manual knots\nfit_gcv <- pamm(\n  ped_status ~ s(tend, bs = \"ps\", k = k_mgcv, m = c(m_order, m_order)),\n  data = ped,\n  method = \"GCV.Cp\",\n  knots = list(tend = mgcv_knots)\n)\n\n# Fit PAM with REML\nfit_reml <- pamm(\n  ped_status ~ s(tend, bs = \"ps\", k = k_mgcv, m = c(m_order, m_order)),\n  data = ped,\n  method = \"REML\",\n  knots = list(tend = mgcv_knots)\n)\n\ncat(\"\\n=== mgcv/pammtools Results (P-splines with Julia knots) ===\\n\")\ncat(\"k =\", k_mgcv, \", m =\", m_order, \"\\n\")\ncat(\"Manual knots used:\", round(mgcv_knots, 3), \"\\n\")\n\ncat(\"\\nGCV.Cp:\\n\")\ncat(\"  sp =\", round(fit_gcv$sp, 6), \"\\n\")\ncat(\"  EDF =\", round(sum(fit_gcv$edf), 4), \"\\n\")\n\ncat(\"\\nREML:\\n\")\ncat(\"  sp =\", round(fit_reml$sp, 6), \"\\n\")\ncat(\"  EDF =\", round(sum(fit_reml$edf), 4), \"\\n\")\n```\n:::\n\n\n## flexsurv Fit\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# flexsurv uses knots on log(time) scale, so we need to transform\n# But we can specify explicit knots via the knots argument\n# flexsurv's \"knots\" argument takes the interior knots on the log scale\n\n# Transform interior knots to log scale for flexsurv\n# Note: flexsurv interprets knots as on log(time) scale\nlog_interior_knots <- log(interior_knots)\n\ncat(\"Using same interior knots as Julia (transformed to log scale for flexsurv):\\n\")\ncat(\"  Original knots:\", round(interior_knots, 3), \"\\n\")\ncat(\"  Log-scale knots:\", round(log_interior_knots, 3), \"\\n\")\n\n# Fit flexsurv spline model with the same knots\nfit_flex <- flexsurvspline(\n  Surv(time, status) ~ 1,\n  data = surv_data,\n  knots = log_interior_knots,  # Interior knots on log scale\n  scale = \"hazard\"\n)\n\n# Also fit true Weibull for reference\nfit_weibull <- flexsurvreg(\n  Surv(time, status) ~ 1,\n  data = surv_data,\n  dist = \"weibullPH\"\n)\n\ncat(\"\\n=== flexsurv Results ===\\n\")\ncat(\"\\nSpline model (\", length(interior_knots), \" interior knots):\\n\", sep=\"\")\ncat(\"  AIC =\", round(AIC(fit_flex), 2), \"\\n\")\n\ncat(\"\\nWeibull fit (for reference):\\n\")\ncat(\"  Estimated shape:\", round(exp(fit_weibull$res[\"shape\", \"est\"]), 3), \"\\n\")\ncat(\"  Estimated scale:\", round(exp(fit_weibull$res[\"scale\", \"est\"]), 3), \"\\n\")\ncat(\"  True shape:\", true_shape, \"\\n\")\ncat(\"  True rate:\", true_rate, \"\\n\")\n```\n:::\n\n\n## Effective Degrees of Freedom Comparison\n\nThe **effective degrees of freedom (EDF)** is the proper metric for comparing smoothing\nacross different software packages. EDF measures how many parameters the smooth effectively\nuses, independent of λ scaling conventions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Collect EDF results - this is the key comparison metric\nedf_summary <- rbind(\n  julia_summary %>% \n    mutate(Package = \"MultistateModels.jl\") %>%\n    select(Package, Method = method, EDF = edf, Lambda_or_sp = lambda),\n  data.frame(\n    Package = c(\"mgcv\", \"mgcv\"),\n    Method = c(\"GCV.Cp\", \"REML\"),\n    EDF = c(sum(fit_gcv$edf), sum(fit_reml$edf)),\n    Lambda_or_sp = c(fit_gcv$sp, fit_reml$sp)\n  )\n)\n\nkable(edf_summary, digits = 4,\n      caption = \"Effective Degrees of Freedom by Method (Key Comparison)\",\n      col.names = c(\"Package\", \"Method\", \"EDF\", \"λ or sp\")) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  column_spec(3, bold = TRUE, background = \"#f0f9e8\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Effective Degrees of Freedom by Method (Key Comparison)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> EDF </th>\n   <th style=\"text-align:right;\"> λ or sp </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV5 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV10 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV20 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.4619 </td>\n   <td style=\"text-align:right;\"> 5.4739 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV5 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV20 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.2110 </td>\n   <td style=\"text-align:right;\"> 9.9742 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.0023 </td>\n   <td style=\"text-align:right;\"> 312141.0244 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> REML </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.0005 </td>\n   <td style=\"text-align:right;\"> 1541837.6019 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Model Selection Criteria (AIC/BIC)\n\nFor model comparison, we compute AIC and BIC based on the penalized log-likelihood\nand effective degrees of freedom:\n\n- **AIC** = $-2 \\cdot \\ell + 2 \\cdot \\text{EDF}$\n- **BIC** = $-2 \\cdot \\ell + \\log(n) \\cdot \\text{EDF}$\n\n\n::: {.cell}\n\n```{.r .cell-code}\nn_obs <- nrow(surv_data)\n\n# Julia model selection criteria\njulia_aic_bic <- julia_summary %>%\n  mutate(\n    Package = \"MultistateModels.jl\",\n    AIC = -2 * loglik + 2 * edf,\n    BIC = -2 * loglik + log(n_obs) * edf\n  ) %>%\n  select(Package, Method = method, EDF = edf, LogLik = loglik, AIC, BIC)\n\n# For mgcv: The Poisson pseudo-likelihood differs from survival likelihood by\n# an offset correction. The relationship is:\n#   ℓ_Poisson = ℓ_Survival + Σ_i δ_i * offset_i\n# where offset_i = log(interval_width) for the event interval.\n# Therefore: ℓ_Survival = ℓ_Poisson - Σ_i δ_i * offset_i\n\ncompute_surv_loglik_mgcv <- function(fit_gam, ped) {\n  # Get Poisson log-likelihood\n  mu_hat <- fitted(fit_gam)\n  y <- ped$ped_status\n  poisson_ll <- sum(y * log(mu_hat) - mu_hat)\n  \n  # Correction: subtract sum of offsets for event pseudo-observations\n  event_offsets <- ped$offset[ped$ped_status == 1]\n  offset_correction <- sum(event_offsets)\n  \n  # Survival log-likelihood\n  surv_ll <- poisson_ll - offset_correction\n  return(surv_ll)\n}\n\n# Compute survival log-likelihoods for mgcv models\nloglik_mgcv_gcv <- compute_surv_loglik_mgcv(fit_gcv, ped)\nloglik_mgcv_reml <- compute_surv_loglik_mgcv(fit_reml, ped)\n\n# mgcv model selection using survival log-likelihood\nmgcv_aic_bic <- data.frame(\n  Package = c(\"mgcv\", \"mgcv\"),\n  Method = c(\"GCV.Cp\", \"REML\"),\n  EDF = c(sum(fit_gcv$edf), sum(fit_reml$edf)),\n  LogLik = c(loglik_mgcv_gcv, loglik_mgcv_reml),\n  AIC = c(-2 * loglik_mgcv_gcv + 2 * sum(fit_gcv$edf),\n          -2 * loglik_mgcv_reml + 2 * sum(fit_reml$edf)),\n  BIC = c(-2 * loglik_mgcv_gcv + log(n_obs) * sum(fit_gcv$edf),\n          -2 * loglik_mgcv_reml + log(n_obs) * sum(fit_reml$edf))\n)\n\n# flexsurv model selection\nflex_aic_bic <- data.frame(\n  Package = \"flexsurv\",\n  Method = \"spline\",\n  EDF = length(coef(fit_flex)),\n  LogLik = fit_flex$loglik,\n  AIC = AIC(fit_flex),\n  BIC = BIC(fit_flex)\n)\n\naic_bic_summary <- rbind(julia_aic_bic, mgcv_aic_bic, flex_aic_bic)\n\nn_julia_methods <- nrow(julia_aic_bic)\nkable(aic_bic_summary, digits = 2,\n      caption = \"Model Selection Criteria by Method (Survival Log-Likelihood)\") %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  pack_rows(\"MultistateModels.jl\", 1, n_julia_methods) %>%\n  pack_rows(\"mgcv\", n_julia_methods + 1, n_julia_methods + 2) %>%\n  pack_rows(\"flexsurv\", n_julia_methods + 3, n_julia_methods + 3)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Model Selection Criteria by Method (Survival Log-Likelihood)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> EDF </th>\n   <th style=\"text-align:right;\"> LogLik </th>\n   <th style=\"text-align:right;\"> AIC </th>\n   <th style=\"text-align:right;\"> BIC </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"9\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>MultistateModels.jl</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV5 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV10 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV20 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 2.46 </td>\n   <td style=\"text-align:right;\"> -163.85 </td>\n   <td style=\"text-align:right;\"> 332.63 </td>\n   <td style=\"text-align:right;\"> 339.04 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV5 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV20 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.58 </td>\n   <td style=\"text-align:right;\"> 338.34 </td>\n  </tr>\n  <tr grouplength=\"2\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>mgcv</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;\"> 2.00 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.16 </td>\n   <td style=\"text-align:right;\"> 337.37 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> mgcv </td>\n   <td style=\"text-align:left;\"> REML </td>\n   <td style=\"text-align:right;\"> 2.00 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 332.16 </td>\n   <td style=\"text-align:right;\"> 337.37 </td>\n  </tr>\n  <tr grouplength=\"1\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>flexsurv</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> flexsurv </td>\n   <td style=\"text-align:left;\"> spline </td>\n   <td style=\"text-align:right;\"> 7.00 </td>\n   <td style=\"text-align:right;\"> -160.31 </td>\n   <td style=\"text-align:right;\"> 334.62 </td>\n   <td style=\"text-align:right;\"> 352.85 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n**Note on mgcv log-likelihood:** The mgcv package reports Poisson pseudo-likelihood values, \nnot survival log-likelihood. We convert using the relationship: \n$\\ell_{\\text{survival}} = \\ell_{\\text{Poisson}} - \\sum_i \\delta_i \\cdot \\text{offset}_i$,\nwhere $\\text{offset}_i = \\log(\\text{interval width})$ for each event's interval.\n\n**Key observations:**\n\n- All methods produce similar log-likelihoods (within ~2-3 units), validating correctness\n- EDF values are in the range 2-3, indicating similar effective smoothness across methods\n- Julia's exact likelihood and mgcv's PAM/Poisson approach agree well\n\n## Hazard Function Comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Evaluation grid\neval_times <- seq(0.01, max_time, length.out = 200)\n\n# True hazard\nh_true <- true_hazard(eval_times)\n\n# mgcv/pammtools predictions - use pammtools helper\nnewdata_mgcv <- data.frame(tend = eval_times)\nh_mgcv_gcv <- predict(fit_gcv, newdata = newdata_mgcv, type = \"response\") / \n              mean(diff(ped$tend[1:2]))  # Hazard = rate / interval_length\nh_mgcv_reml <- predict(fit_reml, newdata = newdata_mgcv, type = \"response\") /\n               mean(diff(ped$tend[1:2]))\n\n# Simpler: use pammtools add_hazard for proper hazard extraction\nhazard_mgcv_gcv <- add_hazard(newdata_mgcv, fit_gcv)\nhazard_mgcv_reml <- add_hazard(newdata_mgcv, fit_reml)\n\n# flexsurv hazard\nh_flex <- summary(fit_flex, t = eval_times, type = \"hazard\")[[1]]$est\n\n# Julia curves from CSV (methods: PIJCV, EFS, LOOCV, CV10)\njulia_h <- julia_curves %>% filter(method == \"Julia PIJCV\") %>% pull(hazard)\njulia_h_efs <- julia_curves %>% filter(method == \"Julia EFS\") %>% pull(hazard)\njulia_h_loocv <- julia_curves %>% filter(method == \"Julia LOOCV\") %>% pull(hazard)\njulia_h_cv10 <- julia_curves %>% filter(method == \"Julia CV10\") %>% pull(hazard)\n\n# Combine for plotting\nhazard_df <- data.frame(\n  time = rep(eval_times, 7),\n  hazard = c(h_true, julia_h, julia_h_efs, julia_h_loocv, julia_h_cv10,\n             hazard_mgcv_gcv$hazard, h_flex),\n  method = factor(rep(c(\"True (Weibull)\", \"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\",\n                        \"mgcv GCV\", \"flexsurv\"), \n                      each = length(eval_times)),\n                  levels = c(\"True (Weibull)\", \"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\",\n                             \"mgcv GCV\", \"flexsurv\"))\n)\n\nggplot(hazard_df, aes(x = time, y = hazard, color = method, linetype = method)) +\n  geom_line(linewidth = 1) +\n  geom_rug(data = surv_data %>% filter(status == 1), \n           aes(x = time), inherit.aes = FALSE, \n           color = \"gray30\", alpha = 0.5, sides = \"b\") +\n  scale_color_manual(values = c(\"True (Weibull)\" = \"black\", \n                                 \"Julia PIJCV\" = \"#D55E00\",\n                                 \"Julia EFS\" = \"#56B4E9\",\n                                 \"Julia LOOCV\" = \"#0072B2\",\n                                 \"Julia CV10\" = \"#F0E442\",\n                                 \"mgcv GCV\" = \"#E69F00\",\n                                 \"flexsurv\" = \"#009E73\")) +\n  scale_linetype_manual(values = c(\"True (Weibull)\" = \"solid\",\n                                    \"Julia PIJCV\" = \"dashed\",\n                                    \"Julia EFS\" = \"twodash\",\n                                    \"Julia LOOCV\" = \"longdash\",\n                                    \"Julia CV10\" = \"dashed\",\n                                    \"mgcv GCV\" = \"dotdash\",\n                                    \"flexsurv\" = \"solid\")) +\n  labs(\n    title = \"Hazard Function Estimates\",\n    subtitle = paste0(\"True: Weibull(shape=\", true_shape, \", rate=\", true_rate, \"); rug = event times\"),\n    x = \"Time\",\n    y = \"Hazard h(t)\",\n    color = \"Method\",\n    linetype = \"Method\"\n  ) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/hazard-comparison-1.png){width=960}\n:::\n:::\n\n\n## Cumulative Hazard Comparison\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# True cumulative hazard\nH_true <- true_cumhaz(eval_times)\n\n# Julia cumulative hazard from CSV (methods: PIJCV, EFS, LOOCV, CV10)\njulia_H <- julia_curves %>% filter(method == \"Julia PIJCV\") %>% pull(cumhaz)\njulia_H_efs <- julia_curves %>% filter(method == \"Julia EFS\") %>% pull(cumhaz)\njulia_H_loocv <- julia_curves %>% filter(method == \"Julia LOOCV\") %>% pull(cumhaz)\njulia_H_cv10 <- julia_curves %>% filter(method == \"Julia CV10\") %>% pull(cumhaz)\n\n# mgcv cumulative hazard - compute by numerical integration of hazard\nH_mgcv_gcv <- cumsum(hazard_mgcv_gcv$hazard) * diff(eval_times)[1]\n\n# flexsurv cumulative hazard\nH_flex <- summary(fit_flex, t = eval_times, type = \"cumhaz\")[[1]]$est\n\n# Combine for plotting\ncumhaz_df <- data.frame(\n  time = rep(eval_times, 7),\n  cumhaz = c(H_true, julia_H, julia_H_efs, julia_H_loocv, julia_H_cv10,\n             H_mgcv_gcv, H_flex),\n  method = factor(rep(c(\"True (Weibull)\", \"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\",\n                        \"mgcv GCV\", \"flexsurv\"), \n                      each = length(eval_times)),\n                  levels = c(\"True (Weibull)\", \"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\",\n                             \"mgcv GCV\", \"flexsurv\"))\n)\n\nggplot(cumhaz_df, aes(x = time, y = cumhaz, color = method, linetype = method)) +\n  geom_line(linewidth = 1) +\n  scale_color_manual(values = c(\"True (Weibull)\" = \"black\", \n                                 \"Julia PIJCV\" = \"#D55E00\",\n                                 \"Julia EFS\" = \"#56B4E9\",\n                                 \"Julia LOOCV\" = \"#0072B2\",\n                                 \"Julia CV10\" = \"#F0E442\",\n                                 \"mgcv GCV\" = \"#E69F00\",\n                                 \"flexsurv\" = \"#009E73\")) +\n  scale_linetype_manual(values = c(\"True (Weibull)\" = \"solid\",\n                                    \"Julia PIJCV\" = \"dashed\",\n                                    \"Julia EFS\" = \"twodash\",\n                                    \"Julia LOOCV\" = \"longdash\",\n                                    \"Julia CV10\" = \"dashed\",\n                                    \"mgcv GCV\" = \"dotdash\",\n                                    \"flexsurv\" = \"solid\")) +\n  labs(\n    title = \"Cumulative Hazard Estimates\",\n    x = \"Time\",\n    y = \"Cumulative Hazard H(t)\",\n    color = \"Method\",\n    linetype = \"Method\"\n  ) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/cumhaz-comparison-1.png){width=960}\n:::\n:::\n\n\n## Survival and Cumulative Incidence Curves\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# True survival/CIF\nS_true <- true_surv(eval_times)\nF_true <- true_cdf(eval_times)\n\n# Julia survival from CSV (methods: PIJCV, EFS, LOOCV, CV10)\njulia_S <- julia_curves %>% filter(method == \"Julia PIJCV\") %>% pull(survival)\njulia_S_efs <- julia_curves %>% filter(method == \"Julia EFS\") %>% pull(survival)\njulia_S_loocv <- julia_curves %>% filter(method == \"Julia LOOCV\") %>% pull(survival)\njulia_S_cv10 <- julia_curves %>% filter(method == \"Julia CV10\") %>% pull(survival)\n\n# Julia CIF\nF_julia <- 1 - julia_S\nF_julia_efs <- 1 - julia_S_efs\nF_julia_loocv <- 1 - julia_S_loocv\nF_julia_cv10 <- 1 - julia_S_cv10\n\n# mgcv survival - compute from cumulative hazard (S = exp(-H))\nS_mgcv_gcv <- exp(-H_mgcv_gcv)\nF_mgcv_gcv <- 1 - S_mgcv_gcv\n\n# flexsurv survival\nS_flex <- summary(fit_flex, t = eval_times, type = \"survival\")[[1]]$est\nF_flex <- 1 - S_flex\n\n# Color palette for all methods\nmethod_colors <- c(\"True (Weibull)\" = \"black\", \n                   \"Julia PIJCV\" = \"#D55E00\",\n                   \"Julia EFS\" = \"#56B4E9\",\n                   \"Julia LOOCV\" = \"#0072B2\",\n                   \"Julia CV10\" = \"#F0E442\",\n                   \"mgcv GCV\" = \"#E69F00\",\n                   \"flexsurv\" = \"#009E73\")\n\nmethod_linetypes <- c(\"True (Weibull)\" = \"solid\",\n                      \"Julia PIJCV\" = \"dashed\",\n                      \"Julia EFS\" = \"twodash\",\n                      \"Julia LOOCV\" = \"longdash\",\n                      \"Julia CV10\" = \"dashed\",\n                      \"mgcv GCV\" = \"dotdash\",\n                      \"flexsurv\" = \"solid\")\n\nmethod_levels <- c(\"True (Weibull)\", \"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\",\n                   \"mgcv GCV\", \"flexsurv\")\n\n# Combine survival curves\nsurv_df <- data.frame(\n  time = rep(eval_times, 7),\n  survival = c(S_true, julia_S, julia_S_efs, julia_S_loocv, julia_S_cv10,\n               S_mgcv_gcv, S_flex),\n  method = factor(rep(method_levels, each = length(eval_times)), levels = method_levels)\n)\n\n# Combine CIF curves\ncif_df <- data.frame(\n  time = rep(eval_times, 7),\n  cif = c(F_true, F_julia, F_julia_efs, F_julia_loocv, F_julia_cv10,\n          F_mgcv_gcv, F_flex),\n  method = factor(rep(method_levels, each = length(eval_times)), levels = method_levels)\n)\n\n# Kaplan-Meier for reference\nkm_fit <- survfit(Surv(time, status) ~ 1, data = surv_data)\n\n# Plot survival\np_surv <- ggplot(surv_df, aes(x = time, y = survival, color = method, linetype = method)) +\n  geom_line(linewidth = 1) +\n  geom_step(data = data.frame(time = km_fit$time, survival = km_fit$surv),\n            aes(x = time, y = survival), \n            inherit.aes = FALSE, color = \"gray50\", alpha = 0.5, linewidth = 0.8) +\n  scale_color_manual(values = method_colors) +\n  scale_linetype_manual(values = method_linetypes) +\n  labs(\n    title = \"Survival Function S(t)\",\n    subtitle = \"Gray step function = Kaplan-Meier estimate\",\n    x = \"Time\",\n    y = \"S(t)\",\n    color = \"Method\",\n    linetype = \"Method\"\n  ) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n\n# Plot CIF\np_cif <- ggplot(cif_df, aes(x = time, y = cif, color = method, linetype = method)) +\n  geom_line(linewidth = 1) +\n  geom_step(data = data.frame(time = km_fit$time, cif = 1 - km_fit$surv),\n            aes(x = time, y = cif), \n            inherit.aes = FALSE, color = \"gray50\", alpha = 0.5, linewidth = 0.8) +\n  geom_rug(data = surv_data %>% filter(status == 1), \n           aes(x = time), inherit.aes = FALSE, \n           color = \"gray30\", alpha = 0.5, sides = \"b\") +\n  scale_color_manual(values = method_colors) +\n  scale_linetype_manual(values = method_linetypes) +\n  labs(\n    title = \"Cumulative Incidence F(t) = 1 - S(t)\",\n    subtitle = \"Gray step function = 1 - Kaplan-Meier; rug = event times\",\n    x = \"Time\",\n    y = \"F(t)\",\n    color = \"Method\",\n    linetype = \"Method\"\n  ) +\n  theme(legend.position = \"bottom\") +\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n\np_surv / p_cif\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/survival-comparison-1.png){width=960}\n:::\n:::\n\n\n## Accuracy Metrics\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# RMSE function\nrmse <- function(true, est) sqrt(mean((true - est)^2))\n\n# Get all Julia methods from CSV\njulia_methods <- unique(julia_curves$method)\n\n# Calculate RMSE for all Julia methods\njulia_metrics <- lapply(julia_methods, function(m) {\n  h <- julia_curves %>% filter(method == m) %>% pull(hazard)\n  H <- julia_curves %>% filter(method == m) %>% pull(cumhaz)\n  S <- julia_curves %>% filter(method == m) %>% pull(survival)\n  \n  data.frame(\n    Package = \"MultistateModels.jl\",\n    Method = gsub(\"Julia \", \"\", m),\n    Hazard_RMSE = rmse(h_true, h),\n    CumHaz_RMSE = rmse(H_true, H),\n    Survival_RMSE = rmse(S_true, S)\n  )\n}) %>% bind_rows()\n\n# Add R package results\nr_metrics <- data.frame(\n  Package = c(\"mgcv\", \"flexsurv\"),\n  Method = c(\"GCV.Cp\", \"spline\"),\n  Hazard_RMSE = c(rmse(h_true, hazard_mgcv_gcv$hazard), rmse(h_true, h_flex)),\n  CumHaz_RMSE = c(rmse(H_true, H_mgcv_gcv), rmse(H_true, H_flex)),\n  Survival_RMSE = c(rmse(S_true, S_mgcv_gcv), rmse(S_true, S_flex))\n)\n\n# Combine and order\nmetrics_df <- rbind(julia_metrics, r_metrics)\n\n# Order Julia methods logically (no GCV)\njulia_order <- c(\"PIJCV\", \"PIJCV5\", \"PIJCV10\", \"PIJCV20\", \n                 \"EFS\", \"LOOCV\", \"CV5\", \"CV10\", \"CV20\")\nmetrics_df$Method <- factor(metrics_df$Method, \n                            levels = c(julia_order, \"GCV.Cp\", \"spline\"))\nmetrics_df <- metrics_df %>% arrange(Method)\n\n# Dynamically determine row indices\nn_julia <- nrow(julia_metrics)\nn_r <- nrow(r_metrics)\n\nkable(metrics_df, digits = 5,\n      caption = \"RMSE vs True Weibull Functions\",\n      col.names = c(\"Package\", \"Method\", \"Hazard\", \"Cum. Hazard\", \"Survival\")) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  pack_rows(\"MultistateModels.jl\", 1, n_julia) %>%\n  pack_rows(\"R\", n_julia + 1, n_julia + n_r)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>RMSE vs True Weibull Functions</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> Hazard </th>\n   <th style=\"text-align:right;\"> Cum. Hazard </th>\n   <th style=\"text-align:right;\"> Survival </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"9\"><td colspan=\"5\" style=\"border-bottom: 1px solid;\"><strong>MultistateModels.jl</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV5 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV10 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV20 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 0.09035 </td>\n   <td style=\"text-align:right;\"> 0.18065 </td>\n   <td style=\"text-align:right;\"> 0.03499 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV5 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV20 </td>\n   <td style=\"text-align:right;\"> 0.10004 </td>\n   <td style=\"text-align:right;\"> 0.19374 </td>\n   <td style=\"text-align:right;\"> 0.03596 </td>\n  </tr>\n  <tr grouplength=\"2\"><td colspan=\"5\" style=\"border-bottom: 1px solid;\"><strong>R</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;\"> 0.08143 </td>\n   <td style=\"text-align:right;\"> 0.17682 </td>\n   <td style=\"text-align:right;\"> 0.03317 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> flexsurv </td>\n   <td style=\"text-align:left;\"> spline </td>\n   <td style=\"text-align:right;\"> 0.09084 </td>\n   <td style=\"text-align:right;\"> 0.15412 </td>\n   <td style=\"text-align:right;\"> 0.02948 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Runtime Comparison\n\nA key advantage of Newton-approximated cross-validation methods (PIJCV, PIJCV5, etc.)\nis computational efficiency. While exact k-fold CV requires refitting the model K times,\nthe Newton approximation achieves similar results in a single optimization.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Check if runtime data is available\nif (\"runtime_sec\" %in% names(julia_summary)) {\n  \n  # Categorize methods (no GCV)\n  julia_summary$category <- case_when(\n    julia_summary$method %in% c(\"PIJCV\", \"PIJCV5\", \"PIJCV10\", \"PIJCV20\") ~ \"Newton-approximated CV\",\n    julia_summary$method %in% c(\"LOOCV\", \"CV5\", \"CV10\", \"CV20\") ~ \"Exact CV\",\n    TRUE ~ \"Other (EFS)\"\n  )\n  \n  # Order methods by category and folds (no GCV)\n  method_order <- c(\"PIJCV\", \"PIJCV5\", \"PIJCV10\", \"PIJCV20\", \n                    \"EFS\",\n                    \"LOOCV\", \"CV5\", \"CV10\", \"CV20\")\n  julia_summary$method <- factor(julia_summary$method, levels = method_order)\n  \n  # Create bar plot\n  p_runtime <- ggplot(julia_summary, aes(x = method, y = runtime_sec, fill = category)) +\n    geom_col(width = 0.7) +\n    geom_text(aes(label = sprintf(\"%.2fs\", runtime_sec)), \n              vjust = -0.5, size = 3) +\n    scale_fill_manual(values = c(\n      \"Newton-approximated CV\" = \"#3498db\",\n      \"Exact CV\" = \"#e74c3c\",\n      \"Other (EFS)\" = \"#2ecc71\"\n    )) +\n    labs(\n      title = \"Runtime Comparison: Smoothing Parameter Selection Methods\",\n      subtitle = \"Single optimization vs. K refits (n=100 subjects, 5 interior knots)\",\n      x = \"Method\",\n      y = \"Runtime (seconds)\",\n      fill = \"Category\"\n    ) +\n    theme_minimal() +\n    theme(\n      axis.text.x = element_text(angle = 45, hjust = 1),\n      legend.position = \"bottom\"\n    )\n  \n  print(p_runtime)\n  \n  # Runtime summary table\n  runtime_summary <- julia_summary %>%\n    group_by(category) %>%\n    summarise(\n      Methods = paste(method, collapse = \", \"),\n      Mean_Runtime = mean(runtime_sec),\n      Min_Runtime = min(runtime_sec),\n      Max_Runtime = max(runtime_sec),\n      .groups = \"drop\"\n    ) %>%\n    arrange(Mean_Runtime)\n  \n  kable(runtime_summary, digits = 3,\n        caption = \"Runtime Summary by Method Category\",\n        col.names = c(\"Category\", \"Methods\", \"Mean (s)\", \"Min (s)\", \"Max (s)\")) %>%\n    kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n  \n} else {\n  cat(\"Runtime data not available in julia_summary.\\n\")\n}\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/runtime-comparison-1.png){width=960}\n:::\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Runtime Summary by Method Category</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Category </th>\n   <th style=\"text-align:left;\"> Methods </th>\n   <th style=\"text-align:right;\"> Mean (s) </th>\n   <th style=\"text-align:right;\"> Min (s) </th>\n   <th style=\"text-align:right;\"> Max (s) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> Newton-approximated CV </td>\n   <td style=\"text-align:left;\"> PIJCV, PIJCV5, PIJCV10, PIJCV20 </td>\n   <td style=\"text-align:right;\"> 0.476 </td>\n   <td style=\"text-align:right;\"> 0.456 </td>\n   <td style=\"text-align:right;\"> 0.503 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Other (EFS) </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 0.512 </td>\n   <td style=\"text-align:right;\"> 0.512 </td>\n   <td style=\"text-align:right;\"> 0.512 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> Exact CV </td>\n   <td style=\"text-align:left;\"> LOOCV, CV5, CV10, CV20 </td>\n   <td style=\"text-align:right;\"> 5.449 </td>\n   <td style=\"text-align:right;\"> 1.118 </td>\n   <td style=\"text-align:right;\"> 14.504 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nif (\"runtime_sec\" %in% names(julia_summary)) {\n  # Add category if not present (from previous chunk)\n  if (!\"category\" %in% names(julia_summary)) {\n    julia_summary$category <- case_when(\n      julia_summary$method %in% c(\"PIJCV\", \"PIJCV5\", \"PIJCV10\", \"PIJCV20\") ~ \"Newton CV\",\n      julia_summary$method %in% c(\"LOOCV\", \"CV5\", \"CV10\", \"CV20\") ~ \"Exact CV\",\n      TRUE ~ \"Other\"\n    )\n  }\n  \n  # Full runtime table with all metrics\n  runtime_full <- julia_summary %>%\n    select(method, category, lambda, edf, loglik, runtime_sec) %>%\n    arrange(runtime_sec)\n  \n  kable(runtime_full, digits = c(0, 0, 2, 2, 2, 3),\n        caption = \"Full Results: All Julia Smoothing Methods (sorted by runtime)\",\n        col.names = c(\"Method\", \"Category\", \"λ\", \"EDF\", \"Log-Lik\", \"Runtime (s)\")) %>%\n    kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n}\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Full Results: All Julia Smoothing Methods (sorted by runtime)</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:left;\"> Category </th>\n   <th style=\"text-align:right;\"> λ </th>\n   <th style=\"text-align:right;\"> EDF </th>\n   <th style=\"text-align:right;\"> Log-Lik </th>\n   <th style=\"text-align:right;\"> Runtime (s) </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> PIJCV10 </td>\n   <td style=\"text-align:left;\"> Newton-approximated CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 0.456 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PIJCV5 </td>\n   <td style=\"text-align:left;\"> Newton-approximated CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 0.471 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PIJCV20 </td>\n   <td style=\"text-align:left;\"> Newton-approximated CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 0.475 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:left;\"> Newton-approximated CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 0.503 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:left;\"> Other (EFS) </td>\n   <td style=\"text-align:right;\"> 5.47 </td>\n   <td style=\"text-align:right;\"> 2.46 </td>\n   <td style=\"text-align:right;\"> -163.85 </td>\n   <td style=\"text-align:right;\"> 0.512 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CV5 </td>\n   <td style=\"text-align:left;\"> Exact CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 1.118 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:left;\"> Exact CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 2.275 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> CV20 </td>\n   <td style=\"text-align:left;\"> Exact CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 3.900 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:left;\"> Exact CV </td>\n   <td style=\"text-align:right;\"> 9.97 </td>\n   <td style=\"text-align:right;\"> 2.21 </td>\n   <td style=\"text-align:right;\"> -164.08 </td>\n   <td style=\"text-align:right;\"> 14.504 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n**Key Runtime Observations:**\n\n- **Newton-approximated methods** (PIJCV, PIJCV5, PIJCV10, PIJCV20) achieve comparable \n  accuracy to exact CV while requiring only **a single model fit** with analytical gradients\n- **Exact k-fold CV** methods (LOOCV, CV5, CV10, CV20) require K model refits, \n  making them substantially slower\n- **GCV and EFS** are the fastest as they use simple closed-form approximations\n- The computational advantage of Newton approximation grows with sample size and model complexity\n\n## Discussion\n\n### EDF vs λ Scaling\n\nThe **effective degrees of freedom (EDF)** is the proper metric for comparing smoothing\nacross packages. Despite significant differences in raw λ values between Julia and mgcv,\nthe EDF values are in good agreement, confirming that both approaches select similar \nmodel complexity.\n\nThe scale difference arises from:\n\n1. **Effective sample size**: Julia uses n=100 subjects; mgcv's PAM uses many pseudo-observations\n2. **Penalty matrix normalization**: Different scaling conventions\n3. **Likelihood formulation**: Exact survival vs Poisson pseudo-likelihood\n\n### Software Packages Compared\n\n| Package | Approach | Notes |\n|---------|----------|-------|\n| **MultistateModels.jl** | Exact penalized likelihood with P-splines | Multiple smoothing methods (PIJCV, EFS, LOOCV, etc.) |\n| **mgcv/pammtools** | PAM (Poisson GAM on piecewise-exponential data) | GCV.Cp, REML for smoothing selection |\n| **flexsurv** | Spline hazard via ML (no explicit smoothing parameter) | Uses natural splines, not penalized |\n\n---\n\n# Part 2: Illness-Death Model\n\nWe now extend the analysis to a three-state illness-death model, which is more complex\ndue to competing risks and transition-specific hazards:\n\n```\nState 1 (Healthy) → State 2 (Ill) → State 3 (Dead)\n                  ↘ State 3 (Dead) ↗\n```\n\nThree distinct transitions with different hazard functions:\n\n- **h12** (Healthy → Ill): Moderately increasing hazard (disease onset)\n- **h13** (Healthy → Dead): Decreasing hazard (early competing risk)\n- **h23** (Ill → Dead): Strongly increasing hazard (death after illness)\n\n## True Model Specification (Illness-Death)\n\nData are simulated from Weibull hazards with transition-specific parameters:\n\n| Transition | Shape ($\\kappa$) | Rate ($\\lambda$) | Hazard Pattern |\n|------------|------------------|------------------|----------------|\n| 1→2 | 1.3 | 0.25 | Moderately increasing |\n| 1→3 | 0.8 | 0.15 | Decreasing (competing risk) |\n| 2→3 | 1.5 | 0.35 | Strongly increasing |\n\n$$h_{12}(t) = 1.3 \\times 0.25 \\times t^{0.3} = 0.325 t^{0.3}$$\n$$h_{13}(t) = 0.8 \\times 0.15 \\times t^{-0.2} = 0.12 t^{-0.2}$$\n$$h_{23}(t) = 1.5 \\times 0.35 \\times t^{0.5} = 0.525 t^{0.5}$$\n\n## Illness-Death Data Simulation and Julia Fitting\n\n\n::: {.cell}\n\n```{.bash .cell-code}\ncd ../..\njulia --project=. -e '\nusing MultistateModels\nusing Random\nusing DataFrames\nusing CSV\nusing Printf\nusing Distributions\n\n# Configuration\nn = 200\nmax_time = 6.0\nseed = 12345\n\n# True Weibull parameters (shape, rate) for each transition\n# Using MultistateModels convention: h(t) = shape * rate * t^(shape-1)\ntrue_params = (\n    h12 = (shape = 1.3, rate = 0.25),  # Moderately increasing\n    h13 = (shape = 0.8, rate = 0.15),  # Decreasing (competing risk)\n    h23 = (shape = 1.5, rate = 0.35)   # Strongly increasing\n)\n\nRandom.seed!(seed)\n\n# Simulate illness-death model\n# For each subject, we need to simulate the competing process\n\nfunction weibull_cdf(t, shape, rate)\n    return 1.0 - exp(-rate * t^shape)\nend\n\nfunction weibull_quantile(p, shape, rate)\n    return (-log(1.0 - p) / rate)^(1.0 / shape)\nend\n\n# Simulate event times\nsurvival_data = DataFrame[]\n\nfor i in 1:n\n    # Generate latent event times from state 1\n    U12 = rand()\n    U13 = rand()\n    \n    # Weibull event times from state 1\n    T12 = weibull_quantile(U12, true_params.h12.shape, true_params.h12.rate)\n    T13 = weibull_quantile(U13, true_params.h13.shape, true_params.h13.rate)\n    \n    # Determine first event from state 1\n    if min(T12, T13) >= max_time\n        # Administrative censoring in state 1\n        push!(survival_data, DataFrame(\n            id = i,\n            tstart = 0.0,\n            tstop = max_time,\n            statefrom = 1,\n            stateto = 1,\n            obstype = 1\n        ))\n    elseif T12 < T13\n        # Transition to illness (state 2)\n        t_illness = T12\n        \n        # Now generate death time from state 2\n        # Time to death from illness follows Weibull with params h23\n        U23 = rand()\n        T23_residual = weibull_quantile(U23, true_params.h23.shape, true_params.h23.rate)\n        T_death = t_illness + T23_residual\n        \n        if T_death >= max_time\n            # Illness then administrative censoring\n            push!(survival_data, DataFrame(\n                id = i,\n                tstart = 0.0,\n                tstop = t_illness,\n                statefrom = 1,\n                stateto = 2,\n                obstype = 1\n            ))\n            push!(survival_data, DataFrame(\n                id = i,\n                tstart = t_illness,\n                tstop = max_time,\n                statefrom = 2,\n                stateto = 2,\n                obstype = 1\n            ))\n        else\n            # Illness then death\n            push!(survival_data, DataFrame(\n                id = i,\n                tstart = 0.0,\n                tstop = t_illness,\n                statefrom = 1,\n                stateto = 2,\n                obstype = 1\n            ))\n            push!(survival_data, DataFrame(\n                id = i,\n                tstart = t_illness,\n                tstop = T_death,\n                statefrom = 2,\n                stateto = 3,\n                obstype = 1\n            ))\n        end\n    else\n        # Direct death from state 1 (h13)\n        push!(survival_data, DataFrame(\n            id = i,\n            tstart = 0.0,\n            tstop = T13,\n            statefrom = 1,\n            stateto = 3,\n            obstype = 1\n        ))\n    end\nend\n\nsurv_data = vcat(survival_data...)\n\n# Count transitions\nn_12 = sum((surv_data.statefrom .== 1) .& (surv_data.stateto .== 2))\nn_13 = sum((surv_data.statefrom .== 1) .& (surv_data.stateto .== 3))\nn_23 = sum((surv_data.statefrom .== 2) .& (surv_data.stateto .== 3))\nn_cens_1 = sum((surv_data.statefrom .== 1) .& (surv_data.stateto .== 1))\nn_cens_2 = sum((surv_data.statefrom .== 2) .& (surv_data.stateto .== 2))\n\nprintln(\"=== Illness-Death Data ===\")\nprintln(\"n = $n subjects\")\nprintln(\"Transitions 1→2 (illness): $n_12\")\nprintln(\"Transitions 1→3 (direct death): $n_13\")\nprintln(\"Transitions 2→3 (death after illness): $n_23\")\nprintln(\"Censored in state 1: $n_cens_1\")\nprintln(\"Censored in state 2: $n_cens_2\")\n\n# Extract event times for each transition\nevent_times_12 = surv_data[(surv_data.statefrom .== 1) .& (surv_data.stateto .== 2), :tstop]\nevent_times_13 = surv_data[(surv_data.statefrom .== 1) .& (surv_data.stateto .== 3), :tstop]\nevent_times_23 = surv_data[(surv_data.statefrom .== 2) .& (surv_data.stateto .== 3), :tstop] .- \n                 surv_data[(surv_data.statefrom .== 2) .& (surv_data.stateto .== 3), :tstart]\n\n# For R export, we need the raw survival data\n# Convert to standard multistate format\nCSV.write(\"MultistateModelsTests/reports/_id_surv_data.csv\", surv_data)\n\n# Define model with spline hazards\nh12 = Hazard(@formula(0 ~ 1), \"sp\", 1, 2;\n             degree = 3,\n             knots = Float64[],\n             boundaryknots = [0.0, max_time],\n             natural_spline = true)\nh13 = Hazard(@formula(0 ~ 1), \"sp\", 1, 3;\n             degree = 3,\n             knots = Float64[],\n             boundaryknots = [0.0, max_time],\n             natural_spline = true)\nh23 = Hazard(@formula(0 ~ 1), \"sp\", 2, 3;\n             degree = 3,\n             knots = Float64[],\n             boundaryknots = [0.0, max_time],\n             natural_spline = true)\n\nmodel = multistatemodel(h12, h13, h23; data=surv_data)\n\n# Calibrate knots based on event times\nprintln(\"\\nCalibrating spline knots...\")\nknot_result = calibrate_splines!(model; nknots=5, verbose=true)\n\n# Extract knots for each hazard\nknots_12 = knot_result.h12\nknots_13 = knot_result.h13\nknots_23 = knot_result.h23\n\nprintln(\"\\n=== Knot Configuration ===\")\nprintln(\"h12: boundary=$(knots_12.boundary_knots), interior=$(round.(knots_12.interior_knots, digits=3))\")\nprintln(\"h13: boundary=$(knots_13.boundary_knots), interior=$(round.(knots_13.interior_knots, digits=3))\")\nprintln(\"h23: boundary=$(knots_23.boundary_knots), interior=$(round.(knots_23.interior_knots, digits=3))\")\n\n# Save knots for R\nknots_df = DataFrame(\n    transition = repeat([\"h12\", \"h13\", \"h23\"], inner=5),\n    interior_knot_idx = repeat(1:5, 3),\n    interior_knot = vcat(knots_12.interior_knots, knots_13.interior_knots, knots_23.interior_knots),\n    boundary_lower = fill(0.0, 15),\n    boundary_upper = fill(max_time, 15)\n)\nCSV.write(\"MultistateModelsTests/reports/_id_knots.csv\", knots_df)\n\n# Fit with each smoothing method\nprintln(\"\\n=== Fitting with smoothing methods ===\")\n\nprintln(\"\\nFitting with PIJCV method...\")\nresult_pijcv = select_smoothing_parameters(model, SplinePenalty(); \n                                           method = :pijcv, verbose = false)\nprintln(\"  PIJCV λ = $(round.(result_pijcv.lambda, digits=2)), EDF = $(round(result_pijcv.edf.total, digits=2))\")\n\nprintln(\"\\nFitting with EFS method...\")\nresult_efs = select_smoothing_parameters(model, SplinePenalty(); \n                                         method = :efs, verbose = false)\nprintln(\"  EFS λ = $(round.(result_efs.lambda, digits=2)), EDF = $(round(result_efs.edf.total, digits=2))\")\n\nprintln(\"\\nFitting with LOOCV method...\")\nresult_loocv = select_smoothing_parameters(model, SplinePenalty(); \n                                           method = :loocv, verbose = false)\nprintln(\"  LOOCV λ = $(round.(result_loocv.lambda, digits=2)), EDF = $(round(result_loocv.edf.total, digits=2))\")\n\nprintln(\"\\nFitting with 10-fold CV method...\")\nresult_cv10 = select_smoothing_parameters(model, SplinePenalty(); \n                                          method = :cv10, verbose = false)\nprintln(\"  CV10 λ = $(round.(result_cv10.lambda, digits=2)), EDF = $(round(result_cv10.edf.total, digits=2))\")\n\n# Evaluation grid\neval_times = collect(range(0.01, max_time, length=200))\n\n# Function to evaluate hazard curves for all transitions\nfunction evaluate_id_curves(model, beta, eval_times)\n    results = Dict{String, NamedTuple}()\n    \n    current_idx = 1\n    for (idx, haz) in enumerate(model.hazards)\n        trans_name = \"h$(haz.statefrom)$(haz.stateto)\"\n        \n        # Get parameter indices for this hazard\n        npars = length(haz.parnames)\n        start_idx = current_idx\n        end_idx = current_idx + npars - 1\n        beta_haz = beta[start_idx:end_idx]\n        current_idx = end_idx + 1\n        \n        hazard_vals = [haz.hazard_fn(t, beta_haz, ()) for t in eval_times]\n        cumhaz_vals = [haz.cumhaz_fn(0.0, t, beta_haz, ()) for t in eval_times]\n        \n        results[trans_name] = (hazard = hazard_vals, cumhaz = cumhaz_vals)\n    end\n    \n    return results\nend\n\n# Compute curves for each method\ncurves_pijcv = evaluate_id_curves(model, result_pijcv.beta, eval_times)\ncurves_efs = evaluate_id_curves(model, result_efs.beta, eval_times)\ncurves_loocv = evaluate_id_curves(model, result_loocv.beta, eval_times)\ncurves_cv10 = evaluate_id_curves(model, result_cv10.beta, eval_times)\n\n# Compute unpenalized log-likelihoods\nsamplepaths = MultistateModels.extract_paths(model)\nexact_data = MultistateModels.ExactData(model, samplepaths)\nloglik_pijcv = MultistateModels.loglik_exact(result_pijcv.beta, exact_data; neg=false)\nloglik_efs = MultistateModels.loglik_exact(result_efs.beta, exact_data; neg=false)\nloglik_loocv = MultistateModels.loglik_exact(result_loocv.beta, exact_data; neg=false)\nloglik_cv10 = MultistateModels.loglik_exact(result_cv10.beta, exact_data; neg=false)\n\n# Save curves to CSV\ncurves_list = DataFrame[]\nfor (method_name, curves) in [(\"Julia PIJCV\", curves_pijcv), \n                               (\"Julia EFS\", curves_efs), (\"Julia LOOCV\", curves_loocv), \n                               (\"Julia CV10\", curves_cv10)]\n    for trans in [\"h12\", \"h13\", \"h23\"]\n        push!(curves_list, DataFrame(\n            time = eval_times,\n            hazard = curves[trans].hazard,\n            cumhaz = curves[trans].cumhaz,\n            transition = trans,\n            method = method_name\n        ))\n    end\nend\njulia_curves = vcat(curves_list...)\nCSV.write(\"MultistateModelsTests/reports/_id_julia_curves.csv\", julia_curves)\n\n# Save summary with per-transition EDF\njulia_summary = DataFrame(\n    method = [\"PIJCV\", \"EFS\", \"LOOCV\", \"CV10\"],\n    lambda = [result_pijcv.lambda[1], result_efs.lambda[1], \n              result_loocv.lambda[1], result_cv10.lambda[1]],\n    edf_total = [result_pijcv.edf.total, result_efs.edf.total, \n                 result_loocv.edf.total, result_cv10.edf.total],\n    loglik = [loglik_pijcv, loglik_efs, loglik_loocv, loglik_cv10]\n)\nCSV.write(\"MultistateModelsTests/reports/_id_julia_summary.csv\", julia_summary)\n\n# Save event times for rug plots\nevent_times_df = DataFrame(\n    time = Float64[],\n    transition = String[]\n)\nfor (times, trans) in [(event_times_12, \"h12\"), (event_times_13, \"h13\")]\n    append!(event_times_df, DataFrame(time = times, transition = fill(trans, length(times))))\nend\n# For h23, use the absolute death times (not duration in state 2)\ndeath_times_23 = surv_data[(surv_data.statefrom .== 2) .& (surv_data.stateto .== 3), :tstop]\nappend!(event_times_df, DataFrame(time = death_times_23, transition = fill(\"h23\", length(death_times_23))))\nCSV.write(\"MultistateModelsTests/reports/_id_event_times.csv\", event_times_df)\n\nprintln(\"\\nIllness-death curves computed and saved.\")\n'\n```\n:::\n\n\n## Load Illness-Death Results in R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load simulated data\nid_surv_data <- read.csv(\"_id_surv_data.csv\")\n\n# Load Julia curves\nid_julia_curves <- read.csv(\"_id_julia_curves.csv\")\nid_julia_summary <- read.csv(\"_id_julia_summary.csv\")\n\n# Load knots\nid_knots_df <- read.csv(\"_id_knots.csv\")\nid_knots <- id_knots_df %>%\n  group_by(transition) %>%\n  summarise(\n    interior_knots = list(interior_knot),\n    boundary_lower = first(boundary_lower),\n    boundary_upper = first(boundary_upper),\n    .groups = \"drop\"\n  )\n\n# Load event times for rug plots\nid_event_times <- read.csv(\"_id_event_times.csv\")\n\n# True parameters\nid_true_params <- list(\n  h12 = list(shape = 1.3, rate = 0.25),\n  h13 = list(shape = 0.8, rate = 0.15),\n  h23 = list(shape = 1.5, rate = 0.35)\n)\n\nid_max_time <- 6.0\nid_n <- length(unique(id_surv_data$id))\n\ncat(\"=== Illness-Death Julia Results ===\\n\")\nprint(id_julia_summary)\n\ncat(\"\\n=== Knot Configuration ===\\n\")\nfor (trans in c(\"h12\", \"h13\", \"h23\")) {\n  knots_trans <- id_knots %>% filter(transition == trans)\n  cat(trans, \": interior = [\", paste(round(unlist(knots_trans$interior_knots), 3), collapse=\", \"), \"]\\n\")\n}\n```\n:::\n\n\n## True Hazard Functions (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# True hazard functions for each transition\nid_true_hazard <- function(t, trans) {\n  params <- id_true_params[[trans]]\n  params$shape * params$rate * t^(params$shape - 1)\n}\n\nid_true_cumhaz <- function(t, trans) {\n  params <- id_true_params[[trans]]\n  params$rate * t^params$shape\n}\n```\n:::\n\n\n## mgcv/pammtools Fits (Illness-Death)\n\nFor the illness-death model, we fit separate PAM models for each transition using\npammtools, ensuring the same knots as Julia for each transition.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(survival)\n\n# Create transition-specific datasets for PAM fitting\n# For multi-state models, we need to filter to relevant observations\n\n# h12: Observations starting in state 1\nid_data_h12 <- id_surv_data %>%\n  filter(statefrom == 1) %>%\n  mutate(\n    time = tstop - tstart,\n    status = as.integer(stateto == 2),\n    id_row = row_number()\n  )\n\n# h13: Same observations, different event indicator\nid_data_h13 <- id_surv_data %>%\n  filter(statefrom == 1) %>%\n  mutate(\n    time = tstop - tstart,\n    status = as.integer(stateto == 3),\n    id_row = row_number()\n  )\n\n# h23: Observations starting in state 2\nid_data_h23 <- id_surv_data %>%\n  filter(statefrom == 2) %>%\n  mutate(\n    time = tstop - tstart,\n    status = as.integer(stateto == 3),\n    id_row = row_number()\n  )\n\ncat(\"h12 data: n =\", nrow(id_data_h12), \", events =\", sum(id_data_h12$status), \"\\n\")\ncat(\"h13 data: n =\", nrow(id_data_h13), \", events =\", sum(id_data_h13$status), \"\\n\")\ncat(\"h23 data: n =\", nrow(id_data_h23), \", events =\", sum(id_data_h23$status), \"\\n\")\n\n# Function to build mgcv knots from Julia interior knots\nbuild_mgcv_knots <- function(interior_knots, boundary_lower, boundary_upper) {\n  k_mgcv <- length(interior_knots) + 4\n  m_order <- 2\n  middle_knots <- c(boundary_lower, interior_knots, boundary_upper)\n  delta <- mean(diff(middle_knots))\n  padding_lower <- boundary_lower - (3:1) * delta\n  padding_upper <- boundary_upper + (1:3) * delta\n  c(padding_lower, middle_knots, padding_upper)\n}\n\n# Build knot vectors for each transition\nid_mgcv_knots <- list()\nfor (trans in c(\"h12\", \"h13\", \"h23\")) {\n  knots_trans <- id_knots %>% filter(transition == trans)\n  id_mgcv_knots[[trans]] <- build_mgcv_knots(\n    unlist(knots_trans$interior_knots),\n    knots_trans$boundary_lower,\n    knots_trans$boundary_upper\n  )\n}\n\nk_mgcv <- 9  # 5 interior + 4\nm_order <- 2\n\n# Fit PAM for h12\nped_h12 <- as_ped(\n  formula = Surv(time, status) ~ 1,\n  data = id_data_h12,\n  id = \"id_row\"\n)\n\nfit_h12_gcv <- pamm(\n  ped_status ~ s(tend, bs = \"ps\", k = k_mgcv, m = c(m_order, m_order)),\n  data = ped_h12,\n  method = \"GCV.Cp\",\n  knots = list(tend = id_mgcv_knots[[\"h12\"]])\n)\n\ncat(\"\\nh12 mgcv fit: EDF =\", round(sum(fit_h12_gcv$edf), 2), \"\\n\")\n\n# Fit PAM for h13\nped_h13 <- as_ped(\n  formula = Surv(time, status) ~ 1,\n  data = id_data_h13,\n  id = \"id_row\"\n)\n\nfit_h13_gcv <- pamm(\n  ped_status ~ s(tend, bs = \"ps\", k = k_mgcv, m = c(m_order, m_order)),\n  data = ped_h13,\n  method = \"GCV.Cp\",\n  knots = list(tend = id_mgcv_knots[[\"h13\"]])\n)\n\ncat(\"h13 mgcv fit: EDF =\", round(sum(fit_h13_gcv$edf), 2), \"\\n\")\n\n# Fit PAM for h23\nped_h23 <- as_ped(\n  formula = Surv(time, status) ~ 1,\n  data = id_data_h23,\n  id = \"id_row\"\n)\n\nfit_h23_gcv <- pamm(\n  ped_status ~ s(tend, bs = \"ps\", k = k_mgcv, m = c(m_order, m_order)),\n  data = ped_h23,\n  method = \"GCV.Cp\",\n  knots = list(tend = id_mgcv_knots[[\"h23\"]])\n)\n\ncat(\"h23 mgcv fit: EDF =\", round(sum(fit_h23_gcv$edf), 2), \"\\n\")\n```\n:::\n\n\n## Effective Degrees of Freedom (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Collect EDF results for illness-death model\nid_edf_summary <- rbind(\n  id_julia_summary %>%\n    mutate(Package = \"MultistateModels.jl\") %>%\n    select(Package, Method = method, EDF = edf_total, Lambda = lambda),\n  data.frame(\n    Package = rep(\"mgcv\", 3),\n    Method = c(\"GCV h12\", \"GCV h13\", \"GCV h23\"),\n    EDF = c(sum(fit_h12_gcv$edf), sum(fit_h13_gcv$edf), sum(fit_h23_gcv$edf)),\n    Lambda = c(fit_h12_gcv$sp, fit_h13_gcv$sp, fit_h23_gcv$sp)\n  )\n)\n\nkable(id_edf_summary, digits = 4,\n      caption = \"Effective Degrees of Freedom - Illness-Death Model\",\n      col.names = c(\"Package\", \"Method\", \"EDF (total)\", \"λ\")) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  column_spec(3, bold = TRUE, background = \"#f0f9e8\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Effective Degrees of Freedom - Illness-Death Model</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> EDF (total) </th>\n   <th style=\"text-align:right;\"> λ </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 19.7050 </td>\n   <td style=\"text-align:right;\"> 0.0003 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 6.3034 </td>\n   <td style=\"text-align:right;\"> 14.8797 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 5.6492 </td>\n   <td style=\"text-align:right;\"> 27.1126 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 5.2354 </td>\n   <td style=\"text-align:right;\"> 40.4473 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV h12 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.0159 </td>\n   <td style=\"text-align:right;\"> 55576.6194 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV h13 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.1753 </td>\n   <td style=\"text-align:right;\"> 1449.0671 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV h23 </td>\n   <td style=\"text-align:right;font-weight: bold;background-color: rgba(240, 249, 232, 255) !important;\"> 2.0024 </td>\n   <td style=\"text-align:right;\"> 169676.9961 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Model Selection Criteria (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nid_n_obs <- id_n\n\n# Julia AIC/BIC\nid_julia_aic_bic <- id_julia_summary %>%\n  mutate(\n    Package = \"MultistateModels.jl\",\n    AIC = -2 * loglik + 2 * edf_total,\n    BIC = -2 * loglik + log(id_n_obs) * edf_total\n  ) %>%\n  select(Package, Method = method, EDF = edf_total, LogLik = loglik, AIC, BIC)\n\nkable(id_julia_aic_bic, digits = 2,\n      caption = \"Model Selection Criteria - Illness-Death Model\") %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\"))\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>Model Selection Criteria - Illness-Death Model</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> EDF </th>\n   <th style=\"text-align:right;\"> LogLik </th>\n   <th style=\"text-align:right;\"> AIC </th>\n   <th style=\"text-align:right;\"> BIC </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 19.70 </td>\n   <td style=\"text-align:right;\"> -621.04 </td>\n   <td style=\"text-align:right;\"> 1281.48 </td>\n   <td style=\"text-align:right;\"> 1346.48 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 6.30 </td>\n   <td style=\"text-align:right;\"> -633.16 </td>\n   <td style=\"text-align:right;\"> 1278.92 </td>\n   <td style=\"text-align:right;\"> 1299.71 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 5.65 </td>\n   <td style=\"text-align:right;\"> -633.91 </td>\n   <td style=\"text-align:right;\"> 1279.13 </td>\n   <td style=\"text-align:right;\"> 1297.76 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 5.24 </td>\n   <td style=\"text-align:right;\"> -634.53 </td>\n   <td style=\"text-align:right;\"> 1279.52 </td>\n   <td style=\"text-align:right;\"> 1296.79 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Hazard Function Comparison (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Evaluation grid\nid_eval_times <- seq(0.01, id_max_time, length.out = 200)\n\n# Get mgcv hazard predictions\nid_newdata <- data.frame(tend = id_eval_times)\n\nhazard_mgcv_h12 <- add_hazard(id_newdata, fit_h12_gcv)\nhazard_mgcv_h13 <- add_hazard(id_newdata, fit_h13_gcv)\nhazard_mgcv_h23 <- add_hazard(id_newdata, fit_h23_gcv)\n\n# Color palette\nid_method_colors <- c(\"True (Weibull)\" = \"black\",\n                      \"Julia PIJCV\" = \"#D55E00\",\n                      \"Julia EFS\" = \"#56B4E9\",\n                      \"Julia LOOCV\" = \"#0072B2\",\n                      \"Julia CV10\" = \"#F0E442\",\n                      \"mgcv GCV\" = \"#E69F00\")\n\nid_method_linetypes <- c(\"True (Weibull)\" = \"solid\",\n                         \"Julia PIJCV\" = \"dashed\",\n                         \"Julia EFS\" = \"twodash\",\n                         \"Julia LOOCV\" = \"longdash\",\n                         \"Julia CV10\" = \"dashed\",\n                         \"mgcv GCV\" = \"dotdash\")\n\n# Create hazard plots for each transition\ncreate_hazard_plot <- function(trans, trans_label) {\n  # True hazard\n  h_true <- id_true_hazard(id_eval_times, trans)\n  \n  # Julia hazards\n  julia_methods <- c(\"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\")\n  julia_hazards <- lapply(julia_methods, function(m) {\n    id_julia_curves %>%\n      filter(transition == trans, method == m) %>%\n      pull(hazard)\n  })\n  \n  # mgcv hazard\n  mgcv_haz <- switch(trans,\n    h12 = hazard_mgcv_h12$hazard,\n    h13 = hazard_mgcv_h13$hazard,\n    h23 = hazard_mgcv_h23$hazard\n  )\n  \n  # Combine data\n  hazard_df <- data.frame(\n    time = rep(id_eval_times, 6),\n    hazard = c(h_true, unlist(julia_hazards), mgcv_haz),\n    method = factor(rep(c(\"True (Weibull)\", julia_methods, \"mgcv GCV\"), each = length(id_eval_times)),\n                    levels = c(\"True (Weibull)\", julia_methods, \"mgcv GCV\"))\n  )\n  \n  # Event times for this transition\n  event_times_trans <- id_event_times %>% filter(transition == trans) %>% pull(time)\n  \n  ggplot(hazard_df, aes(x = time, y = hazard, color = method, linetype = method)) +\n    geom_line(linewidth = 1) +\n    geom_rug(data = data.frame(time = event_times_trans),\n             aes(x = time), inherit.aes = FALSE,\n             color = \"gray30\", alpha = 0.5, sides = \"b\") +\n    scale_color_manual(values = id_method_colors) +\n    scale_linetype_manual(values = id_method_linetypes) +\n    labs(\n      title = paste0(\"Hazard: \", trans_label),\n      x = \"Time\",\n      y = \"h(t)\",\n      color = \"Method\",\n      linetype = \"Method\"\n    ) +\n    theme(legend.position = \"none\")\n}\n\np_h12 <- create_hazard_plot(\"h12\", \"Healthy → Ill (h12)\")\np_h13 <- create_hazard_plot(\"h13\", \"Healthy → Dead (h13)\")\np_h23 <- create_hazard_plot(\"h23\", \"Ill → Dead (h23)\")\n\n# Combine with shared legend\n(p_h12 / p_h13 / p_h23) +\n  plot_layout(guides = \"collect\") &\n  theme(legend.position = \"bottom\") &\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/id-hazard-comparison-1.png){width=960}\n:::\n:::\n\n\n## Cumulative Hazard Comparison (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create cumulative hazard plots for each transition\ncreate_cumhaz_plot <- function(trans, trans_label) {\n  # True cumulative hazard\n  H_true <- id_true_cumhaz(id_eval_times, trans)\n  \n  # Julia cumulative hazards\n  julia_methods <- c(\"Julia PIJCV\", \"Julia EFS\", \"Julia LOOCV\", \"Julia CV10\")\n  julia_cumhaz <- lapply(julia_methods, function(m) {\n    id_julia_curves %>%\n      filter(transition == trans, method == m) %>%\n      pull(cumhaz)\n  })\n  \n  # mgcv cumulative hazard (integrate hazard)\n  mgcv_haz <- switch(trans,\n    h12 = hazard_mgcv_h12$hazard,\n    h13 = hazard_mgcv_h13$hazard,\n    h23 = hazard_mgcv_h23$hazard\n  )\n  mgcv_cumhaz <- cumsum(mgcv_haz) * diff(id_eval_times)[1]\n  \n  # Combine data\n  cumhaz_df <- data.frame(\n    time = rep(id_eval_times, 6),\n    cumhaz = c(H_true, unlist(julia_cumhaz), mgcv_cumhaz),\n    method = factor(rep(c(\"True (Weibull)\", julia_methods, \"mgcv GCV\"), each = length(id_eval_times)),\n                    levels = c(\"True (Weibull)\", julia_methods, \"mgcv GCV\"))\n  )\n  \n  ggplot(cumhaz_df, aes(x = time, y = cumhaz, color = method, linetype = method)) +\n    geom_line(linewidth = 1) +\n    scale_color_manual(values = id_method_colors) +\n    scale_linetype_manual(values = id_method_linetypes) +\n    labs(\n      title = paste0(\"Cumulative Hazard: \", trans_label),\n      x = \"Time\",\n      y = \"H(t)\",\n      color = \"Method\",\n      linetype = \"Method\"\n    ) +\n    theme(legend.position = \"none\")\n}\n\np_H12 <- create_cumhaz_plot(\"h12\", \"Healthy → Ill (h12)\")\np_H13 <- create_cumhaz_plot(\"h13\", \"Healthy → Dead (h13)\")\np_H23 <- create_cumhaz_plot(\"h23\", \"Ill → Dead (h23)\")\n\n(p_H12 / p_H13 / p_H23) +\n  plot_layout(guides = \"collect\") &\n  theme(legend.position = \"bottom\") &\n  guides(color = guide_legend(nrow = 2), linetype = guide_legend(nrow = 2))\n```\n\n::: {.cell-output-display}\n![](spline_comparison_benchmark_files/figure-html/id-cumhaz-comparison-1.png){width=960}\n:::\n:::\n\n\n## Accuracy Metrics (Illness-Death)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# RMSE function\nrmse <- function(true, est) sqrt(mean((true - est)^2, na.rm = TRUE))\n\n# Calculate metrics for each transition and method\nid_metrics_list <- list()\n\nfor (trans in c(\"h12\", \"h13\", \"h23\")) {\n  h_true <- id_true_hazard(id_eval_times, trans)\n  H_true <- id_true_cumhaz(id_eval_times, trans)\n  \n  # Julia methods (no GCV - only PIJCV, EFS, LOOCV, CV10)\n  for (method in c(\"PIJCV\", \"EFS\", \"LOOCV\", \"CV10\")) {\n    julia_method <- paste0(\"Julia \", method)\n    h_julia <- id_julia_curves %>%\n      filter(transition == trans, method == julia_method) %>%\n      pull(hazard)\n    H_julia <- id_julia_curves %>%\n      filter(transition == trans, method == julia_method) %>%\n      pull(cumhaz)\n    \n    id_metrics_list[[paste(trans, method)]] <- data.frame(\n      Transition = trans,\n      Package = \"MultistateModels.jl\",\n      Method = method,\n      Hazard_RMSE = rmse(h_true, h_julia),\n      CumHaz_RMSE = rmse(H_true, H_julia)\n    )\n  }\n  \n  # mgcv\n  mgcv_haz <- switch(trans,\n    h12 = hazard_mgcv_h12$hazard,\n    h13 = hazard_mgcv_h13$hazard,\n    h23 = hazard_mgcv_h23$hazard\n  )\n  mgcv_cumhaz <- cumsum(mgcv_haz) * diff(id_eval_times)[1]\n  \n  id_metrics_list[[paste(trans, \"mgcv\")]] <- data.frame(\n    Transition = trans,\n    Package = \"mgcv\",\n    Method = \"GCV.Cp\",\n    Hazard_RMSE = rmse(h_true, mgcv_haz),\n    CumHaz_RMSE = rmse(H_true, mgcv_cumhaz)\n  )\n}\n\nid_metrics_df <- do.call(rbind, id_metrics_list)\n\nkable(id_metrics_df, digits = 5,\n      caption = \"RMSE vs True Weibull Functions - Illness-Death Model\",\n      col.names = c(\"Transition\", \"Package\", \"Method\", \"Hazard RMSE\", \"Cum. Hazard RMSE\")) %>%\n  kable_styling(bootstrap_options = c(\"striped\", \"hover\")) %>%\n  pack_rows(\"h12: Healthy → Ill\", 1, 5) %>%\n  pack_rows(\"h13: Healthy → Dead\", 6, 10) %>%\n  pack_rows(\"h23: Ill → Dead\", 11, 15)\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table table-striped table-hover\" style=\"margin-left: auto; margin-right: auto;\">\n<caption>RMSE vs True Weibull Functions - Illness-Death Model</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:left;\">  </th>\n   <th style=\"text-align:left;\"> Transition </th>\n   <th style=\"text-align:left;\"> Package </th>\n   <th style=\"text-align:left;\"> Method </th>\n   <th style=\"text-align:right;\"> Hazard RMSE </th>\n   <th style=\"text-align:right;\"> Cum. Hazard RMSE </th>\n  </tr>\n </thead>\n<tbody>\n  <tr grouplength=\"5\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>h12: Healthy → Ill</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h12 PIJCV </td>\n   <td style=\"text-align:left;\"> h12 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 0.08090 </td>\n   <td style=\"text-align:right;\"> 0.18076 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h12 EFS </td>\n   <td style=\"text-align:left;\"> h12 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 0.07463 </td>\n   <td style=\"text-align:right;\"> 0.19951 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h12 LOOCV </td>\n   <td style=\"text-align:left;\"> h12 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 0.07888 </td>\n   <td style=\"text-align:right;\"> 0.20635 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h12 CV10 </td>\n   <td style=\"text-align:left;\"> h12 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 0.08317 </td>\n   <td style=\"text-align:right;\"> 0.21240 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h12 mgcv </td>\n   <td style=\"text-align:left;\"> h12 </td>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;\"> 0.05755 </td>\n   <td style=\"text-align:right;\"> 0.16779 </td>\n  </tr>\n  <tr grouplength=\"5\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>h13: Healthy → Dead</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h13 PIJCV </td>\n   <td style=\"text-align:left;\"> h13 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 0.02777 </td>\n   <td style=\"text-align:right;\"> 0.01456 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h13 EFS </td>\n   <td style=\"text-align:left;\"> h13 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 0.01684 </td>\n   <td style=\"text-align:right;\"> 0.02019 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h13 LOOCV </td>\n   <td style=\"text-align:left;\"> h13 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 0.01795 </td>\n   <td style=\"text-align:right;\"> 0.02509 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h13 CV10 </td>\n   <td style=\"text-align:left;\"> h13 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 0.01926 </td>\n   <td style=\"text-align:right;\"> 0.02897 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h13 mgcv </td>\n   <td style=\"text-align:left;\"> h13 </td>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;\"> 0.02750 </td>\n   <td style=\"text-align:right;\"> 0.03060 </td>\n  </tr>\n  <tr grouplength=\"5\"><td colspan=\"6\" style=\"border-bottom: 1px solid;\"><strong>h23: Ill → Dead</strong></td></tr>\n<tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h23 PIJCV </td>\n   <td style=\"text-align:left;\"> h23 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> PIJCV </td>\n   <td style=\"text-align:right;\"> 0.51615 </td>\n   <td style=\"text-align:right;\"> 0.66691 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h23 EFS </td>\n   <td style=\"text-align:left;\"> h23 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> EFS </td>\n   <td style=\"text-align:right;\"> 0.20845 </td>\n   <td style=\"text-align:right;\"> 0.43839 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h23 LOOCV </td>\n   <td style=\"text-align:left;\"> h23 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> LOOCV </td>\n   <td style=\"text-align:right;\"> 0.24925 </td>\n   <td style=\"text-align:right;\"> 0.51128 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h23 CV10 </td>\n   <td style=\"text-align:left;\"> h23 </td>\n   <td style=\"text-align:left;\"> MultistateModels.jl </td>\n   <td style=\"text-align:left;\"> CV10 </td>\n   <td style=\"text-align:right;\"> 0.28438 </td>\n   <td style=\"text-align:right;\"> 0.57198 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:left;padding-left: 2em;\" indentlevel=\"1\"> h23 mgcv </td>\n   <td style=\"text-align:left;\"> h23 </td>\n   <td style=\"text-align:left;\"> mgcv </td>\n   <td style=\"text-align:left;\"> GCV.Cp </td>\n   <td style=\"text-align:right;\"> 0.21070 </td>\n   <td style=\"text-align:right;\"> 0.41481 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\n## Discussion (Illness-Death Model)\n\nThe illness-death model presents additional challenges compared to simple survival:\n\n1. **Competing risks**: From state 1, subjects can transition to either state 2 (illness) \n   or state 3 (death), requiring proper handling of censoring for each transition.\n\n2. **Transition-specific hazards**: Each transition has its own hazard function with \n   different shapes, testing the flexibility of spline smoothing.\n\n3. **Data sparsity**: Some transitions may have fewer events, affecting the stability \n   of smoothing parameter selection.\n\n**Key observations:**\n\n- All Julia smoothing methods (PIJCV, EFS, LOOCV, CV10) produce similar results\n- EDF values are comparable between Julia and mgcv for each transition\n- The decreasing hazard (h13) is more challenging to capture than increasing hazards\n- The strongly increasing hazard (h23) is well-recovered by all methods\n\n---\n\n# Session Info\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsessionInfo()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.1 (2025-06-13)\nPlatform: aarch64-apple-darwin20\nRunning under: macOS Sequoia 15.7.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRblas.0.dylib \nLAPACK: /Library/Frameworks/R.framework/Versions/4.5-arm64/Resources/lib/libRlapack.dylib;  LAPACK version 3.12.1\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\ntime zone: America/New_York\ntzcode source: internal\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] kableExtra_1.4.0 knitr_1.50       patchwork_1.3.2  flexsurv_2.3.2  \n [5] survival_3.8-3   pammtools_0.7.3  mgcv_1.9-3       nlme_3.1-168    \n [9] lubridate_1.9.4  forcats_1.0.0    stringr_1.5.1    dplyr_1.1.4     \n[13] purrr_1.1.0      readr_2.1.5      tidyr_1.3.1      tibble_3.3.0    \n[17] ggplot2_3.5.2    tidyverse_2.0.0 \n\nloaded via a namespace (and not attached):\n [1] tidyselect_1.2.1    viridisLite_0.4.2   farver_2.1.2       \n [4] fastmap_1.2.0       lazyeval_0.2.2      digest_0.6.37      \n [7] timechange_0.3.0    lifecycle_1.0.4     statmod_1.5.1      \n[10] magrittr_2.0.3      compiler_4.5.1      rlang_1.1.6        \n[13] tools_4.5.1         yaml_2.3.10         data.table_1.17.8  \n[16] labeling_0.4.3      timereg_2.0.7       htmlwidgets_1.6.4  \n[19] xml2_1.4.0          RColorBrewer_1.1-3  withr_3.0.2        \n[22] numDeriv_2016.8-1.1 pec_2025.06.24      grid_4.5.1         \n[25] mstate_0.3.3        future_1.67.0       globals_0.18.0     \n[28] scales_1.4.0        iterators_1.0.14    cli_3.6.5          \n[31] mvtnorm_1.3-3       rmarkdown_2.29      generics_0.1.4     \n[34] rstudioapi_0.17.1   future.apply_1.20.0 tzdb_0.5.0         \n[37] splines_4.5.1       parallel_4.5.1      scam_1.2-20        \n[40] muhaz_1.2.6.4       vctrs_0.6.5         Matrix_1.7-3       \n[43] jsonlite_2.0.0      hms_1.1.3           Formula_1.2-5      \n[46] listenv_0.9.1       systemfonts_1.2.3   foreach_1.5.2      \n[49] glue_1.8.0          parallelly_1.45.1   codetools_0.2-20   \n[52] stringi_1.8.7       gtable_0.3.6        quadprog_1.5-8     \n[55] pillar_1.11.0       htmltools_0.5.8.1   deSolve_1.40       \n[58] lava_1.8.1          R6_2.6.1            textshaping_1.0.1  \n[61] evaluate_1.0.5      lattice_0.22-7      backports_1.5.0    \n[64] Rcpp_1.1.0          svglite_2.2.1       prodlim_2025.04.28 \n[67] checkmate_2.3.3     xfun_0.53           pkgconfig_2.0.3    \n```\n\n\n:::\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clean up temporary files\nunlink(\"_surv_data.csv\")\nunlink(\"_julia_curves.csv\")\nunlink(\"_julia_summary.csv\")\nunlink(\"_knots.csv\")\n\n# Illness-death files\nunlink(\"_id_surv_data.csv\")\nunlink(\"_id_julia_curves.csv\")\nunlink(\"_id_julia_summary.csv\")\nunlink(\"_id_knots.csv\")\nunlink(\"_id_event_times.csv\")\n```\n:::\n\n",
    "supporting": [
      "spline_comparison_benchmark_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}