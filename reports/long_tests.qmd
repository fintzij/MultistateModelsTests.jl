---
title: "Long Test Status"
subtitle: "Parameter Recovery and Validation Tests for MultistateModels.jl"
format:
  html:
    toc: true
    toc-depth: 3
    toc-expand: 2
    code-fold: true
    code-summary: "Show code"
execute:
  echo: true
  warning: false
  freeze: auto
---

```{julia}
#| echo: false
#| output: false
using Pkg
Pkg.activate(joinpath(@__DIR__, ".."))
using MultistateModels
using DataFrames
using Statistics
using CairoMakie
using Printf
using JSON3
using Dates

# Include ReportHelpers for cache loading and plotting
include(joinpath(@__DIR__, "..", "src", "ReportHelpers.jl"))
import .ReportHelpers: load_test_cache, get_cache_status, cache_status_badge,
       results_to_dataframe, get_git_info, get_category_result,
       load_longtest_result, list_longtest_results,
       plot_parameter_recovery, plot_state_prevalence, plot_cumulative_incidence,
       longtest_result_to_parameter_table,
       plot_data_summary, plot_validation_panel, format_test_name,
       create_test_inventory_df
```

## Test Inventory

Long tests validate parameter recovery across all supported model configurations. Each test:

1. **Simulates** data from a model with known true parameters (N=1000 subjects)
2. **Fits** the model to the simulated data  
3. **Compares** estimated parameters to true values
4. **Verifies** distributional properties via prevalence and cumulative incidence plots

```{julia}
#| echo: false
#| output: asis

inventory_df = create_test_inventory_df()

if nrow(inventory_df) == 0
    println("::: {.callout-note}")
    println("## No Results Available")
    println("")
    println("Long test results are saved to `cache/longtest_results/` after each test run.")
    println("To populate these results, run:")
    println("")
    println("```bash")
    println("cd MultistateModelsTests")
    println("MSM_TEST_LEVEL=full julia --project=. -e 'using MultistateModelsTests; MultistateModelsTests.runtests()'")
    println("```")
    println(":::")
else
    n_pass = count(r -> r == "✅ Pass", inventory_df.Status)
    n_total = nrow(inventory_df)
    
    println("### Summary\n")
    println("**$(n_pass)/$(n_total) tests passing** | Last updated: $(Dates.format(now(), "yyyy-mm-dd HH:MM"))\n")
    
    println("\n### Test Matrix\n")
    println("| Test Name | Family | Data Type | Covariates | N | Status |")
    println("|-----------|--------|-----------|------------|---|--------|")
    for row in eachrow(inventory_df)
        println("| `$(row.TestName)` | $(row.Family) | $(row.DataType) | $(row.Covariates) | $(row.NSubjects) | $(row.Status) |")
    end
end
```

## Test Results by Family

```{julia}
#| echo: false
#| output: asis

available_results = list_longtest_results()

if isempty(available_results)
    println("::: {.callout-warning}")
    println("No long test results found in cache.")
    println(":::")
end
```

```{julia}
#| echo: false
#| output: asis

# Group results by family for organized display
family_order = ["exp", "wei", "gom", "pt", "sp"]
family_names = Dict(
    "exp" => "Exponential",
    "wei" => "Weibull",
    "gom" => "Gompertz",
    "pt" => "Phase-Type",
    "sp" => "Spline"
)

# Get all results grouped by family
results_by_family = Dict{String, Vector{Any}}()
for test_name in available_results
    result = load_longtest_result(test_name)
    isnothing(result) && continue
    
    family = get(result, :hazard_family, "")
    if isempty(family)
        # Try to infer from test name or hazard_families field
        families = get(result, :hazard_families, [])
        family = !isempty(families) ? String(first(families)) : "unknown"
    end
    
    if !haskey(results_by_family, family)
        results_by_family[family] = []
    end
    push!(results_by_family[family], result)
end

# Display by family
for fam in family_order
    !haskey(results_by_family, fam) && continue
    results = results_by_family[fam]
    isempty(results) && continue
    
    println("\n### $(get(family_names, fam, fam))\n")
    
    for result in results
        test_name = String(result[:test_name])
        test_desc = String(get(result, :test_description, test_name))
        
        # Try to use formatted name if new fields available
        formatted_name = format_test_name(result)
        if formatted_name != "Unknown - Unknown - Unknown"
            test_desc = formatted_name
        end
        
        println("\n#### $test_desc\n")
        println("**Test:** `$test_name` | **N:** $(result[:n_subjects]) | ")
        println("**Run:** $(result[:timestamp]) on `$(result[:git_branch])` ($(result[:git_commit]))\n")
    end
end
```

```{julia}
#| echo: false

# Display parameter tables and validation panels for each result
for test_name in available_results
    result = load_longtest_result(test_name)
    isnothing(result) && continue
    
    # Format nice name
    formatted_name = format_test_name(result)
    if formatted_name == "Unknown - Unknown - Unknown"
        formatted_name = String(get(result, :test_description, test_name))
    end
    
    println("\n---\n")
    println("### $formatted_name - Details\n")
    
    # Parameter table
    println("\n**Parameter Recovery:**\n")
    param_table = longtest_result_to_parameter_table(result)
    display(param_table)
end
```

```{julia}
#| echo: false
#| fig-width: 10
#| fig-height: 4

# Plot state prevalence for each result
for test_name in available_results
    result = load_longtest_result(test_name)
    isnothing(result) && continue
    
    formatted_name = format_test_name(result)
    if formatted_name == "Unknown - Unknown - Unknown"
        formatted_name = String(get(result, :test_description, test_name))
    end
    
    println("\n**State Prevalence: $formatted_name**\n")
    println("Red = true model, Blue = fitted model\n")
    
    fig = plot_state_prevalence(result)
    display(fig)
end
```

```{julia}
#| echo: false
#| fig-width: 8
#| fig-height: 3

# Plot cumulative incidence for each result
for test_name in available_results
    result = load_longtest_result(test_name)
    isnothing(result) && continue
    
    formatted_name = format_test_name(result)
    if formatted_name == "Unknown - Unknown - Unknown"
        formatted_name = String(get(result, :test_description, test_name))
    end
    
    println("\n**Cumulative Incidence: $formatted_name**\n")
    println("Transitions 1→2 and 2→3 only (progressive model)\n")
    
    fig = plot_cumulative_incidence(result)
    display(fig)
end
```

## Running Long Tests

### Full Suite

```bash
cd MultistateModelsTests

# Via the test package API
MSM_TEST_LEVEL=full julia --project=. -e 'using MultistateModelsTests; MultistateModelsTests.runtests()'

# Or via the dedicated script
julia --project=. scripts/run_longtests.jl
```

### Individual Test Suite

```bash
# Run only a specific suite (by key name)
MSM_TEST_LEVEL=full MSM_LONGTEST_ONLY=parametric_suite julia --project=. -e 'using MultistateModelsTests; MultistateModelsTests.runtests()'
```

### Available Test Suites

| Key | Description |
|-----|-------------|
| `parametric_suite` | Parametric families (exp/wei/gom) × data types × covariates |
| `exact_data` | Exact observation direct MLE |
| `mcem_parametric` | Panel data with parametric hazards |
| `mcem_splines` | Panel data with spline hazards |
| `phasetype` | Phase-type hazard models |
| `variance_validation` | Variance estimation validation |

### Environment Variables

| Variable | Values | Description |
|----------|--------|-------------|
| `MSM_TEST_LEVEL` | `quick` (default), `full` | Controls whether long tests run |
| `MSM_LONGTEST_ONLY` | test key | Run only one specific long test suite |
| `MSM_SUPPRESS_WARNINGS` | `true` (default), `false` | Suppress expected warnings |

## Troubleshooting

### Parameter Recovery Failures

**Symptoms**: Estimated parameters far from true values

**Potential Causes**:
1. **Insufficient sample size**: Tests use N=1000, may need more for some models
2. **Poor initialization**: Check `initialize_parameters!` settings
3. **MCEM convergence**: Increase iterations or tighten tolerance

### Variance Estimation Issues

**Symptoms**: Coverage rates significantly below 95%

**Potential Causes**:
1. **Small sample bias**: Need larger n
2. **Boundary parameters**: Transform scale may help
3. **Model misspecification**: Verify DGP matches fitted model

## Summary

Long tests provide rigorous validation that MultistateModels.jl:

1. **Recovers parameters** within expected tolerance (20% relative error)
2. **Produces valid uncertainty** through variance estimation
3. **Simulates correctly** from fitted models
4. **Handles all supported** hazard families and observation types

The test matrix covers:
- **Families**: Exponential, Weibull, Gompertz, Phase-Type, Spline
- **Data types**: Exact (direct MLE), Panel (Markov/MCEM)
- **Covariates**: None, Time-fixed, Time-varying
